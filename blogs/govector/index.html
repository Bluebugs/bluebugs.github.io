<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Parallel data manipulation to Go | Cedric Bail</title>
<meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="How could we enable Go to manipulate data in parallel efficiently?"><meta name=generator content="Hugo 0.136.0"><meta name=robots content="index, follow"><meta name=author content="Cedric Bail"><link rel=stylesheet href=/ananke/css/main.min.8921c15b0db94cb6b4846a01822db1a5540da83894c06824a2bec89cfbd30d5f.css><link rel=canonical href=http://bluebugs.github.io/blogs/govector/><meta property="og:url" content="http://bluebugs.github.io/blogs/govector/"><meta property="og:site_name" content="Cedric Bail"><meta property="og:title" content="Parallel data manipulation to Go"><meta property="og:description" content="How could we enable Go to manipulate data in parallel efficiently?"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2025-01-12T10:40:28-07:00"><meta property="article:modified_time" content="2025-01-12T10:40:28-07:00"><meta itemprop=name content="Parallel data manipulation to Go"><meta itemprop=description content="How could we enable Go to manipulate data in parallel efficiently?"><meta itemprop=datePublished content="2025-01-12T10:40:28-07:00"><meta itemprop=dateModified content="2025-01-12T10:40:28-07:00"><meta itemprop=wordCount content="1358"><meta name=twitter:card content="summary"><meta name=twitter:title content="Parallel data manipulation to Go"><meta name=twitter:description content="How could we enable Go to manipulate data in parallel efficiently?"></head><body class="ma0 avenir bg-near-white production"><header class="cover bg-center" style=background-image:url(http://bluebugs.github.io/images/bugaboo.jpg)><div class=bg-black-60><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Cedric Bail</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/blogs/ title="Blog page">Blog</a></li></ul><div class=ananke-socials></div></div></div></nav><div class="tc-l pv6 ph3 ph4-ns"><div class="f2 f1-l fw2 white-90 mb0 lh-title">Parallel data manipulation to Go</div><div class="fw1 f5 f3-l white-80 measure-wide-l center lh-copy mt3 mb4">How could we enable Go to manipulate data in parallel efficiently?</div></div></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Blog</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Parallel data manipulation to Go</h1><p class=tracked>By <strong>Cedric Bail</strong></p><time class="f6 mv4 dib tracked" datetime=2025-01-12T10:40:28-07:00>January 12, 2025</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links black pr4-l w-two-thirds-l"><p>In Go, we have the ability to execute multiple concurrent code path (concurrency) in parallel using goroutine. There has been consideration to add concurrency without parallelism with <a href=https://research.swtch.com/coro>coroutine</a>, but we haven&rsquo;t really explored the concept of getting parallelism without concurrency.</p><h1 id=what-is-parallelism-without-concurrency>What is parallelism without concurrency?</h1><p>The idea is that the same code is executed on an array of data in parallel. This is how language like Cuda, OpenCL or even shaders language work with GPU. For shaders, for example, you code the algorithm that is going to be applied to each pixels, for example, and it will execute that code on all the pixels in parallel. Same code, different data. No code concurrency, just data parallelism. And the code can adapt to the capacity of the hardware (number of unit doing computation in parallel) without change.</p><p>For CPU, we have <a href=https://ispc.github.io/>ISPC</a>, which tried to bring this concept to the C ecosystem. <a href=https://github.com/google/highway>Google Highway</a> trying to bring this to the C+ ecosystem. And finally <a href=https://www.modular.com/mojo>Mojo</a> trying to bring this concept with a very modern take to the Python ecosystem. And zig is supporting it natively (<a href=https://www.openmymind.net/SIMD-With-Zig/>here</a> is an example on how to use it).</p><h1 id=why-would-we-want-this-in-the-go-ecosystem>Why would we want this in the Go ecosystem?</h1><p>All Go core library and the vast majority are not taking any advantage of SIMD instructions set which would enable significant speedup when iterating on large-ish data. It is why Go is slower than Node at parsing JSON (Node use <a href=https://simdjson.org/software/>simdjson</a>. There is a very long list of slow functions in the Go standard library:</p><ul><li>encoding/base64: <a href=https://github.com/golang/go/issues/19636>decoding</a>, <a href=https://github.com/golang/go/issues/20206>encoding</a></li><li>image/jpeg: <a href=https://github.com/golang/go/issues/24499>decode</a></li><li>strings/bytes: <a href=https://github.com/golang/go/issues/36891>LastIndexBytes</a></li><li><a href=https://github.com/golang/go/issues/53178>encoding/json</a> and <a href=https://github.com/golang/go/issues/68203>strings escaping</a></li><li><a href=https://github.com/golang/go/issues/63347>unicode/utf8</a></li><li>crypto: [64634]](<a href=https://github.com/golang/go/issues/64634)>https://github.com/golang/go/issues/64634)</a>, <a href=https://github.com/golang/go/issues/21269>21269</a>, <a href=https://github.com/golang/go/issues/22809>22809</a></li><li><a href=https://github.com/golang/go/issues/68188>encoding/hex</a></li></ul><p>Some of them, especially the crypto, are getting an exception, but most can&rsquo;t get any hand written assembly due to <a href=https://go.dev/wiki/AssemblyPolicy>Go policy</a> which I find very meaningful. Arguably, we are in 2025, nobody should have to write assembly by hand anymore, but here we are.</p><p>So if we had a way to express parallelism without concurrency in Go natively, the majority of the open issue above could be solved easily and by anyone writing Go. And likely even 5% improvement would become acceptable.</p><link rel=stylesheet href=/css/vendors/admonitions.6a7530662d08e604d9cddaa1237801a8b81f8a803aba78029e9d00348cdc4c88.css integrity="sha256-anUwZi0I5gTZzdqhI3gBqLgfioA6ungCnp0ANIzcTIg=" crossorigin=anonymous><div class="admonition note"><div class=admonition-header><svg viewBox="0 0 576 512"><path d="M0 64C0 28.7 28.7.0 64 0H224v128c0 17.7 14.3 32 32 32h128v125.7l-86.8 86.8c-10.3 10.3-17.5 23.1-21 37.2l-18.7 74.9c-2.3 9.2-1.8 18.8 1.3 27.5L64 512c-35.3.0-64-28.7-64-64V64zm384 64H256V0L384 128zM549.8 235.7l14.4 14.4c15.6 15.6 15.6 40.9.0 56.6l-29.4 29.4-71-71 29.4-29.4c15.6-15.6 40.9-15.6 56.6.0zM311.9 417 441.1 287.8l71 71L382.9 487.9c-4.1 4.1-9.2 7-14.9 8.4l-60.1 15c-5.5 1.4-11.2-.2-15.2-4.2s-5.6-9.7-4.2-15.2l15-60.1c1.4-5.6 4.3-10.8 8.4-14.9z"/></svg>
<span>Note</span></div><div class=admonition-content><p><em>Auto vectorisation exist.</em> It is the limited ability of the compiler to figure out where it can add parallelism by looking at non explicitly parallel code. This is a nice to have, but nobody in any language seriously rely on it for performance critical task. Which is why all standard library have assembly in them to work around the language limitation. It is also why we do not run just C or C++ on GPU, but we had to invent new language. GPU would not have taken off if everyone had to develop for each of them in assembly.</p></div></div><h1 id=how-would-that-work>How would that work?</h1><p>First a bit of naming convention. Go currently manipulate one data at a time. This single element are called <em>scalar</em> or <em>uniform</em> on GPU. When switching to manipulate multiple data at once, it is usually named <em>varying</em> on GPU or <em>vector</em>. A <em>scalar</em> operation (addition, multiplication, &mldr;) with a <em>vector</em> produce a <em>vector</em>, like so:</p><p>/* FIXME: SVG of a scalar by vector operation */</p><p>A <em>vector</em> operation with a <em>vector</em> result in a vector like so:</p><p>/* FIXME: SVG of a vector by vector operation */</p><h2 id=types>Types</h2><p>We will need the ability to specify that a type is a <em>scalar</em> or a <em>vector</em>. Maybe something like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>a</span> <span style=color:#a6e22e>scalar</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>b</span> <span style=color:#a6e22e>vector</span>(<span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>c</span> <span style=color:#a6e22e>vector</span>(<span style=color:#ae81ff>4</span>) []<span style=color:#66d9ef>int</span> <span style=color:#75715e>// A vector of array of int (each entry of the vector point to a different array)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>d</span> []<span style=color:#a6e22e>vector</span>(<span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>int</span> <span style=color:#75715e>// An array of vector of int (each entry of the array is a vector of int)
</span></span></span></code></pre></div><p>By default, all types would remain <em>scalar</em> in an implicit declaration to keep backward compability with past Go code.</p><h2 id=if><em>IF</em></h2><p>To write algorithm, the first construct we need is the ability to do <code>if</code> in parallel. The idea here is very simple. We will use if, but when operating on <em>vector</em> it will generate a <em>mask</em>. Then the operation inside the <code>if</code> will only update the portion of the <em>vector</em> that is not masked out. In the <code>else</code> branch, we will do exactly the opposite. Once done, we can just restore the <em>mask</em> the wayt it was prior to the <code>if</code>. Let&rsquo;s look at an example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>test</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>vector</span>(<span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>bool</span>{<span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>, <span style=color:#66d9ef>true</span>, <span style=color:#66d9ef>false</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>vector</span>(<span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>b</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>vector</span>(<span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>test</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>r</span> = <span style=color:#a6e22e>a</span> <span style=color:#f92672>*</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>} <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>r</span> = <span style=color:#a6e22e>b</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>vector</span> <span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>})
</span></span></code></pre></div><p>/* FIXME: SVG of the above code */</p><p>Note that all of this code is executed sequentially. Both branch of the if is executed on all the data, just we do not care of the result whne it is masked out. This is manipulating data in parallel, but the code is exactly the same for the entire vector.</p><h2 id=for><em>FOR</em></h2><p>Now, that we have <code>if</code> in parallel, we just need to be able to write <code>for</code> in parallel. The idea of a <code>for</code> in parallel, is that each entry of a <em>vector</em> will have the entire <code>for</code> run for it. If another entry use <code>break</code> or <code>continue</code>, the <code>for</code> will still run for all the other entries of the <em>vector</em>. This is again something we can do by using <em>mask</em>. We will need to remember the <em>mask</em> prior to the <code>for</code> so that we can continue as <code>if</code> no modification on it was done. We will need a <em>mask</em> to use to restore for the next loop. This <em>mask</em> will be altered when <code>break</code> is called. We will use this mask as a starting point of a loop and apply to it the loop condition. If the resulting <em>mask</em> is false, we can exit the loop. This <em>mask</em> is the <em>current loop mask</em>. Finally when encountering a <code>continue</code> inside a <code>for</code>, we can modify permanently the <em>current loop mask</em> to reflect that a column of the <em>vector</em> is not going to be processed anymore in this loop.</p><p>Let&rsquo;s look at an example:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>vector</span>(<span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>}; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>5</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>%</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>break</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>r</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>i</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>vector</span>(<span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>})
</span></span></code></pre></div><p>/* FIXME: SVG of the above code */</p><h2 id=initializing-_vector_>Initializing <em>vector</em></h2><p>So far, we have been manually initializing all our vector with random data. There is definitively benefit to have better and more readable construct. <code>zig</code> use <code>iota</code> to initialize a <em>vector</em> with increment of one for each entry. I think this would work well in Go too. We would be able to do:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>i</span> <span style=color:#a6e22e>vector</span>(<span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>int</span> = <span style=color:#66d9ef>iota</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>assert</span>.<span style=color:#a6e22e>Equal</span>(<span style=color:#a6e22e>t</span>, <span style=color:#a6e22e>r</span>, <span style=color:#a6e22e>vector</span>(<span style=color:#ae81ff>4</span>) <span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>})
</span></span></code></pre></div><p>The other bit missing is the ability to iterate over an existing array of <em>scalar</em> using <em>vector</em>. This would be where we enter a block of code that is operating on <em>vector</em>. The starting point of parallelism. As <code>go</code> introduced the <code>go func</code> combination for concurrency with parallelism aka <em>goroutine</em>, we could use <code>go for</code> combination to introduce parallelism without concurrency. This would look like:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#a6e22e>a</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>3</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>5</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>7</span>, <span style=color:#ae81ff>8</span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r</span> <span style=color:#a6e22e>vector</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>go</span> <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>value</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>a</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>r</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>value</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This would make it possible to write vector length agnostic code and make specifying the vector length optional. We might likely want <code>len</code> on a <em>vector</em> type to return the length of a <em>vector</em>.</p><h2 id=going-from-_vector_-to-_scalar_>Going from <em>vector</em> to <em>scalar</em></h2><p>Very often, we don&rsquo;t just want to manipulate vector, but instead get a <em>scalar</em> as a result. This operation are called <code>reduce</code> in most of the CPU language listed above and it makes sense as we <strong>reduce</strong> our <em>vector</em> to one <em>scalar</em>. All kind of <code>reduce</code> operation should exist, like Add, Mul, Or, &mldr;</p><p>Using this to finish the previous example we would get:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Sum</span>(<span style=color:#a6e22e>a</span> []<span style=color:#66d9ef>int</span>) <span style=color:#66d9ef>int</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r</span> []<span style=color:#a6e22e>vector</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>it</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>a</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>r</span> <span style=color:#f92672>+=</span> <span style=color:#a6e22e>a</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>r</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><ul class=pa0></ul><div class="mt6 instapaper_ignoref"><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//bluebugs.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><div id=commento></div><script defer src=https://cdn.commento.io/js/commento.js></script></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=http://bluebugs.github.io/>&copy; Cedric Bail 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>