<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Putting It All Together | Cedric Bail</title>
<meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Fast IPv4 Parsing with SPMD Go"><meta name=generator content="Hugo 0.136.0"><meta name=robots content="index, follow"><meta name=author content="Cedric Bail"><link rel=stylesheet href=/ananke/css/main.min.b27b18f294c9951b5b631d08d9733f0d7794f951b8e49cdde160a91f5a65f320.css><link rel=canonical href=http://bluebugs.github.io/blogs/go-spmd-ipv4-parser/><meta property="og:url" content="http://bluebugs.github.io/blogs/go-spmd-ipv4-parser/"><meta property="og:site_name" content="Cedric Bail"><meta property="og:title" content="Putting It All Together"><meta property="og:description" content="Fast IPv4 Parsing with SPMD Go"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2025-07-13T14:00:00-07:00"><meta property="article:modified_time" content="2025-07-13T14:00:00-07:00"><meta property="article:tag" content="Golang"><meta property="article:tag" content="Performance"><meta property="article:tag" content="Networking"><meta property="article:tag" content="SIMD"><meta property="article:tag" content="SPMD"><meta itemprop=name content="Putting It All Together"><meta itemprop=description content="Fast IPv4 Parsing with SPMD Go"><meta itemprop=datePublished content="2025-07-13T14:00:00-07:00"><meta itemprop=dateModified content="2025-07-13T14:00:00-07:00"><meta itemprop=wordCount content="1764"><meta itemprop=keywords content="Golang,Performance,Networking,SIMD,SPMD"><meta name=twitter:card content="summary"><meta name=twitter:title content="Putting It All Together"><meta name=twitter:description content="Fast IPv4 Parsing with SPMD Go"></head><body class="ma0 avenir bg-near-white production"><header class="cover bg-center" style=background-image:url(http://bluebugs.github.io/images/lakelouise.jpg)><div class=bg-black-60><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Cedric Bail</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/blogs/ title="Blog page">Blog</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/examples/ title="Code Examples page">Code Examples</a></li></ul><div class=ananke-socials></div></div></div></nav><div class="tc-l pv6 ph3 ph4-ns"><div class="f2 f1-l fw2 white-90 mb0 lh-title">Putting It All Together</div><div class="fw1 f5 f3-l white-80 measure-wide-l center lh-copy mt3 mb4">Fast IPv4 Parsing with SPMD Go</div></div></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Blog</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Putting It All Together</h1><p class=tracked>By <strong>Cedric Bail</strong></p><time class="f6 mv4 dib tracked" datetime=2025-07-13T14:00:00-07:00>July 13, 2025</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links black pr4-l w-two-thirds-l"><p>Network address parsing is ubiquitous in Go applications, yet the standard library implementations process strings character by character, leaving significant performance on the table. In this comprehensive exploration, we&rsquo;ll combine the SPMD concepts from our <a href=../practical-vector/>previous</a> <a href=../cross-lane-communication/>blogs</a> to build a high-performance IPv4 parser inspired by <a href=http://0x80.pl/notesen/2023-04-09-faster-parse-ipv4.html>Wojciech Muła&rsquo;s SIMD research</a>.</p><p>This post demonstrates how SPMD Go could be used to keep code readable, but significantly improve performance by applying the techniques we&rsquo;ve explored: parallel processing, reduction operations, and cross-lane communication. This example is a lot less complex than trying things like base64 and shows the benefit of language-level support for parallel data manipulation in my opinion.</p><h2 id=the-research-foundation>The Research Foundation</h2><p>Wojciech Muła&rsquo;s work on <a href=https://github.com/WojciechMula/toys/tree/master/parseip4>SIMD-ized IPv4 parsing</a> demonstrates that clever parallel algorithms can achieve 2-3x performance improvements over traditional parsing. His approach uses several key insights:</p><ol><li><strong>16-byte parallel processing</strong>: Loading entire IPv4 strings into SIMD registers</li><li><strong>Dot mask generation</strong>: Using parallel comparisons to create bitmasks of dot positions</li><li><strong>Pattern-based field extraction</strong>: Leveraging precomputed lookup tables for field boundaries</li><li><strong>Parallel digit conversion</strong>: Processing all four octets simultaneously</li></ol><p>Our SPMD Go implementation adapts these techniques while maintaining readability and trying to keep it Go idiomatic. It should be readable without knowing assembly SIMD instructions.</p><h2 id=the-traditional-sequential-approach>The Traditional Sequential Approach</h2><p>Go&rsquo;s standard library processes IPv4 addresses character by character:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>parseIPv4Fields</span>(<span style=color:#a6e22e>in</span> <span style=color:#66d9ef>string</span>, <span style=color:#a6e22e>off</span>, <span style=color:#a6e22e>end</span> <span style=color:#66d9ef>int</span>, <span style=color:#a6e22e>fields</span> []<span style=color:#66d9ef>uint8</span>) <span style=color:#66d9ef>error</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>val</span>, <span style=color:#a6e22e>pos</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>digLen</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>s</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>in</span>[<span style=color:#a6e22e>off</span>:<span style=color:#a6e22e>end</span>]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; len(<span style=color:#a6e22e>s</span>); <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>&gt;=</span> <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;9&#39;</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>digLen</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>val</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>parseAddrError</span>{<span style=color:#a6e22e>in</span>: <span style=color:#a6e22e>in</span>, <span style=color:#a6e22e>msg</span>: <span style=color:#e6db74>&#34;IPv4 field has octet with leading zero&#34;</span>}
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>val</span> = <span style=color:#a6e22e>val</span><span style=color:#f92672>*</span><span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> int(<span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>]) <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>digLen</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>val</span> &gt; <span style=color:#ae81ff>255</span> {
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>parseAddrError</span>{<span style=color:#a6e22e>in</span>: <span style=color:#a6e22e>in</span>, <span style=color:#a6e22e>msg</span>: <span style=color:#e6db74>&#34;IPv4 field has value &gt;255&#34;</span>}
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;.&#39;</span> {
</span></span><span style=display:flex><span>            <span style=color:#75715e>// Handle dot logic...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>            <span style=color:#a6e22e>fields</span>[<span style=color:#a6e22e>pos</span>] = uint8(<span style=color:#a6e22e>val</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>pos</span><span style=color:#f92672>++</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>val</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>digLen</span> = <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>parseAddrError</span>{<span style=color:#a6e22e>in</span>: <span style=color:#a6e22e>in</span>, <span style=color:#a6e22e>msg</span>: <span style=color:#e6db74>&#34;unexpected character&#34;</span>}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This sequential approach, while correct and readable, processes one character at a time and can&rsquo;t leverage modern CPU parallelism.</p><h2 id=the-spmd-transformation>The SPMD Transformation</h2><h3 id=phase-1-parallel-character-analysis>Phase 1: Parallel Character Analysis</h3><p>Our SPMD approach begins by analyzing all characters simultaneously using 16-lane processing:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>parseIPv4</span>(<span style=color:#a6e22e>s</span> <span style=color:#66d9ef>string</span>) ([<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>s</span>) &lt; <span style=color:#ae81ff>7</span> <span style=color:#f92672>||</span> len(<span style=color:#a6e22e>s</span>) &gt; <span style=color:#ae81ff>15</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>byte</span>{}, <span style=color:#a6e22e>parseAddrError</span>{<span style=color:#a6e22e>in</span>: <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>msg</span>: <span style=color:#e6db74>&#34;IPv4 address string too short or too long&#34;</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Pad string to 16 bytes with null terminators (like SSE register)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>input</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>16</span>]<span style=color:#66d9ef>byte</span>{}
</span></span><span style=display:flex><span>    copy(<span style=color:#a6e22e>input</span>[:], <span style=color:#a6e22e>s</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Process all 16 lanes in parallel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dotMaskTotal</span> <span style=color:#a6e22e>varying</span>[<span style=color:#ae81ff>16</span>] <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dotMask</span> <span style=color:#a6e22e>varying</span>[<span style=color:#ae81ff>16</span>] <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>digitMask</span> <span style=color:#a6e22e>varying</span>[<span style=color:#ae81ff>16</span>] <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>validChars</span> <span style=color:#a6e22e>varying</span>[<span style=color:#ae81ff>16</span>] <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span>[<span style=color:#ae81ff>16</span>] <span style=color:#a6e22e>input</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dotMask</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;.&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dotMask</span>[<span style=color:#a6e22e>i</span>] {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>dotMaskTotal</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>digitMask</span>[<span style=color:#a6e22e>i</span>] = (<span style=color:#a6e22e>c</span> <span style=color:#f92672>&gt;=</span> <span style=color:#e6db74>&#39;0&#39;</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;9&#39;</span>)
</span></span><span style=display:flex><span>        
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Valid if dot, digit, or null (padding)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#a6e22e>validChars</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>dotMask</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>||</span> <span style=color:#a6e22e>digitMask</span>[<span style=color:#a6e22e>i</span>] <span style=color:#f92672>||</span> <span style=color:#a6e22e>c</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>This parallel analysis validates all characters simultaneously and creates boolean masks for dots and digits—a direct adaptation of Muła&rsquo;s SIMD character classification.</p><p>The key insight here is the <strong>padding strategy</strong>: since we process exactly 16 lanes using <code>range[16] input</code>, we need a consistent 16-byte input. The <code>input := [16]byte{}</code> creates a zero-initialized array, and <code>copy(input[:], s)</code> fills it with the IPv4 string, leaving trailing zeros as padding. The validation logic <code>validChars[i] = dotMask[i] || digitMask[i] || c == 0</code> explicitly accepts null padding, making shorter IPv4 addresses work seamlessly with 16-lane processing.</p><p>After this initial parallel validation phase, the algorithm continues with the original string <code>s</code> for precise boundary calculations and error reporting.</p><h3 id=phase-2-reduction-based-validation>Phase 2: Reduction-Based Validation</h3><p>We use reduction operations to aggregate validation results across all lanes:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#75715e>// Check character validity with precise error location
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>All</span>(<span style=color:#a6e22e>validChars</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>byte</span>{}, <span style=color:#a6e22e>parseAddrError</span>{<span style=color:#a6e22e>in</span>: <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>at</span>: <span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>FindFirstSet</span>(<span style=color:#a6e22e>validChars</span>), <span style=color:#a6e22e>msg</span>: <span style=color:#e6db74>&#34;unexpected character&#34;</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Count dots using reduction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>dotCount</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>Sum</span>(<span style=color:#a6e22e>dotMaskTotal</span>)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>dotCount</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>3</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>byte</span>{}, <span style=color:#a6e22e>parseAddrError</span>{<span style=color:#a6e22e>in</span>: <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>msg</span>: <span style=color:#e6db74>&#34;invalid dot count&#34;</span>}
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Create dot position bitmask (mimics _mm_movemask_epi8)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>dotPositionMask</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>Mask</span>(<span style=color:#a6e22e>dotMask</span>)
</span></span></code></pre></div><p>The <code>reduce.Mask()</code> operation is particularly elegant—it converts the boolean array into a bitmask, directly paralleling SSE&rsquo;s <code>_mm_movemask_epi8</code> instruction.</p><p>Note the improved error reporting: <code>reduce.FindFirstSet(validChars)</code> locates the exact position of the first invalid character, providing precise error messages instead of generic failures. This demonstrates how reduction operations can enhance not just performance, but also debugging and user experience.</p><h3 id=phase-3-race-free-dot-position-extraction>Phase 3: Race-Free Dot Position Extraction</h3><p>Here we solve the potential race condition by using a normal <code>for</code> loop and bit manipulation on the mask instead of having lanes compete to write positions, sometimes you can&rsquo;t do things in parallel:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#75715e>// Extract dot positions using bit manipulation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>dotPositions</span> [<span style=color:#ae81ff>3</span>]<span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>mask</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>dotPositionMask</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> &lt; <span style=color:#ae81ff>3</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>pos</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>bits</span>.<span style=color:#a6e22e>TrailingZeros16</span>(<span style=color:#a6e22e>mask</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>dotPositions</span>[<span style=color:#a6e22e>i</span>] = <span style=color:#a6e22e>pos</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>mask</span> <span style=color:#f92672>&amp;=</span> <span style=color:#a6e22e>mask</span> <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>  <span style=color:#75715e>// Clear lowest set bit
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Define field boundaries as separate arrays for efficient range processing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#a6e22e>starts</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>int</span>{<span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>dotPositions</span>[<span style=color:#ae81ff>0</span>], <span style=color:#a6e22e>dotPositions</span>[<span style=color:#ae81ff>1</span>], <span style=color:#a6e22e>dotPositions</span>[<span style=color:#ae81ff>2</span>]}
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ends</span> <span style=color:#f92672>:=</span> [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>int</span>{<span style=color:#a6e22e>dotPositions</span>[<span style=color:#ae81ff>0</span>], <span style=color:#a6e22e>dotPositions</span>[<span style=color:#ae81ff>1</span>], <span style=color:#a6e22e>dotPositions</span>[<span style=color:#ae81ff>2</span>], len(<span style=color:#a6e22e>s</span>)}
</span></span></code></pre></div><p>This approach eliminates race conditions while extracting dot positions in order, exactly as Wojciech Muła&rsquo;s implementation does with bit manipulation.</p><h3 id=phase-4-parallel-field-validation-and-conversion>Phase 4: Parallel Field Validation and Conversion</h3><p>Now we process all four IPv4 octets in parallel, with each lane handling one field. Note the use of <code>range</code>, this gives the compiler precise information about the iteration count, enabling better optimization:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span>    <span style=color:#75715e>// Validate field lengths in parallel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span>, <span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>starts</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>end</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ends</span>[<span style=color:#a6e22e>i</span>]
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>i</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>start</span><span style=color:#f92672>++</span> <span style=color:#75715e>// Skip the dot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fieldLen</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>end</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>start</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>Any</span>(<span style=color:#a6e22e>fieldLen</span> &lt; <span style=color:#ae81ff>1</span> <span style=color:#f92672>||</span> <span style=color:#a6e22e>fieldLen</span> &gt; <span style=color:#ae81ff>3</span>) {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>byte</span>{}, <span style=color:#a6e22e>parseAddrError</span>{<span style=color:#a6e22e>in</span>: <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>msg</span>: <span style=color:#e6db74>&#34;invalid field length&#34;</span>}
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Process all four fields in parallel
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>ip</span> [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>errors</span> [<span style=color:#ae81ff>4</span>]<span style=color:#a6e22e>parseAddrError</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>hasError</span> <span style=color:#a6e22e>varying</span>[<span style=color:#ae81ff>4</span>] <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>field</span>, <span style=color:#a6e22e>start</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span> <span style=color:#a6e22e>starts</span> {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>end</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ends</span>[<span style=color:#a6e22e>field</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>field</span> &gt; <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>start</span><span style=color:#f92672>++</span> <span style=color:#75715e>// Skip the dot
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        }
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>fieldLen</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>end</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>start</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>value</span> <span style=color:#66d9ef>int</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>hasLeadingZero</span> <span style=color:#66d9ef>bool</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Convert field using optimized digit processing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>switch</span> <span style=color:#a6e22e>fieldLen</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>1</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>value</span> = int(<span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>start</span>] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>2</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>d1</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>start</span>] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>d0</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>start</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>value</span> = <span style=color:#a6e22e>d1</span><span style=color:#f92672>*</span><span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>d0</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>hasLeadingZero</span> = (<span style=color:#a6e22e>d1</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>case</span> <span style=color:#ae81ff>3</span>:
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>d2</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>start</span>] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>d1</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>start</span><span style=color:#f92672>+</span><span style=color:#ae81ff>1</span>] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>d0</span> <span style=color:#f92672>:=</span> int(<span style=color:#a6e22e>s</span>[<span style=color:#a6e22e>start</span><span style=color:#f92672>+</span><span style=color:#ae81ff>2</span>] <span style=color:#f92672>-</span> <span style=color:#e6db74>&#39;0&#39;</span>)
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>value</span> = <span style=color:#a6e22e>d2</span><span style=color:#f92672>*</span><span style=color:#ae81ff>100</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>d1</span><span style=color:#f92672>*</span><span style=color:#ae81ff>10</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>d0</span>
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>hasLeadingZero</span> = (<span style=color:#a6e22e>d2</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#75715e>// Validation and error handling
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>hasLeadingZero</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>errors</span>[<span style=color:#a6e22e>field</span>] = <span style=color:#a6e22e>parseAddrError</span>{<span style=color:#a6e22e>in</span>: <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>msg</span>: <span style=color:#e6db74>&#34;IPv4 field has octet with leading zero&#34;</span>}
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>hasError</span>[<span style=color:#a6e22e>field</span>] = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>value</span> &gt; <span style=color:#ae81ff>255</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>errors</span>[<span style=color:#a6e22e>field</span>] = <span style=color:#a6e22e>parseAddrError</span>{<span style=color:#a6e22e>in</span>: <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>msg</span>: <span style=color:#e6db74>&#34;IPv4 field has value &gt;255&#34;</span>}
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>hasError</span>[<span style=color:#a6e22e>field</span>] = <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>ip</span>[<span style=color:#a6e22e>field</span>] = uint8(<span style=color:#a6e22e>value</span>)
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// Check for errors using reduction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>Any</span>(<span style=color:#a6e22e>hasError</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>byte</span>{}, <span style=color:#a6e22e>errors</span>[<span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>FindFirstSet</span>(<span style=color:#a6e22e>hasError</span>)]
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ip</span>, <span style=color:#66d9ef>nil</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This parallel field processing mirrors Muła&rsquo;s <code>SSE_CONVERT_MAX1/2/3</code> macros, handling different field lengths efficiently while maintaining full validation.</p><h3 id=compiler-optimization-array-range-vs-rangen>Compiler Optimization: Array Range vs Range[N]</h3><p>The use of <code>go for field, start := range starts</code> is a subtle but important optimization. When ranging over an array, the compiler knows the exact iteration count at compile time, enabling:</p><ol><li><strong>Loop unrolling</strong>: The compiler can unroll the loop entirely, generating direct code for each iteration</li><li><strong>Better instruction scheduling</strong>: With known bounds, the compiler can optimize instruction ordering</li><li><strong>Eliminated bounds checks</strong>: No runtime checks needed when array size is compile-time constant</li><li><strong>Eliminate iteration</strong>: In this case especially, the number of iteration, 4, will fit on most architecture in just one SIMD register. So the iteration itself won&rsquo;t be necessary and can be removed.</li></ol><p>This represents a key principle for SPMD Go: give the compiler as much compile-time information as possible to enable maximum optimization.</p><h3 id=enhanced-error-reporting-through-reduction-operations>Enhanced Error Reporting Through Reduction Operations</h3><p>One significant advantage of the SPMD approach in Go itself is improved error reporting. If using SIMD intrinsics and assembly, it is harder to keep track of proper error handling, but with this proposal, it feels a lot more logical and simpler to do proper error reporting, like the locations when validating the initial content of the string:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Instead of generic &#34;unexpected character&#34; 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>All</span>(<span style=color:#a6e22e>validChars</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>byte</span>{}, <span style=color:#a6e22e>parseAddrError</span>{<span style=color:#a6e22e>in</span>: <span style=color:#a6e22e>s</span>, <span style=color:#a6e22e>at</span>: <span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>FindFirstSet</span>(<span style=color:#a6e22e>validChars</span>), <span style=color:#a6e22e>msg</span>: <span style=color:#e6db74>&#34;unexpected character&#34;</span>}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// And precise field error reporting
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>if</span> <span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>Any</span>(<span style=color:#a6e22e>hasError</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [<span style=color:#ae81ff>4</span>]<span style=color:#66d9ef>byte</span>{}, <span style=color:#a6e22e>errors</span>[<span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>FindFirstSet</span>(<span style=color:#a6e22e>hasError</span>)]
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>reduce.FindFirstSet()</code> operation efficiently locates the first lane with an error condition, providing users with exact character positions rather than generic failure messages. This demonstrates how parallel processing in Go enables simpler and idiomatic Go error handling in a simple form.</p><h2 id=performance-implications>Performance Implications</h2><p>This SPMD approach offers several advantages over traditional parsing:</p><ol><li><strong>Character-level parallelism</strong>: All characters validated simultaneously</li><li><strong>Field-level parallelism</strong>: All four octets processed in parallel</li><li><strong>Reduced branching</strong>: Structured validation reduces conditional branches</li><li><strong>Cache efficiency</strong>: Better memory access patterns</li><li><strong>Instruction-level parallelism</strong>: Multiple operations execute simultaneously</li></ol><p>Based on Muła&rsquo;s research, we can expect 2-3x performance improvements on IPv4 parsing. The added code complexity is not the same as if we were writing this with intrinsics, but we rely on the compiler to be able to do all those optimizations.</p><p>ISPC and Mojo have shown it is doable, but there is a lot of work to get there. A potential Proof of Concept could likely be built more easily with TinyGo that uses LLVM like ISPC and would give a validation of the concept.</p><h2 id=the-complexity-trade-off>The Complexity Trade-off</h2><p>While this SPMD approach offers significant performance benefits, it also raises important questions we explored in our <a href=../cross-lane-communication/>cross-lane communication analysis</a>:</p><ul><li><strong>Increased complexity</strong>: The code is harder to understand than sequential parsing</li><li><strong>Debugging challenges</strong>: Parallel bugs are more subtle than sequential ones</li><li><strong>Maintenance overhead</strong>: Requires understanding of SIMD concepts</li></ul><p>However, in this example, the resulting code is readable and maintainable. If it did come with a proper benchmark and the go profiler was able to track the result properly, it should be quite manageable for a lot of developers to write this code, I would think. This is the main justification potential for such an addition. If most developers can write data parallel code and we democratize writing high-performance code, it is worth it. If not, leaving intrinsic and assembly to engineer that can do it might be actually the better way forward. What do you think?</p><p><strong><a href=../../examples/ipv4-parser/>View Complete Source Code</a></strong> - Full implementation with usage examples and detailed comments.</p><h2 id=references>References</h2><ul><li><a href=http://0x80.pl/notesen/2023-04-09-faster-parse-ipv4.html>Wojciech Muła&rsquo;s SIMD IPv4 parsing research</a> - The foundational research this implementation is based on</li><li><a href=https://github.com/WojciechMula/toys/tree/master/parseip4>Muła&rsquo;s IPv4 parsing implementation</a> - Complete SSE implementation and benchmarks</li><li><a href=../practical-vector/>Practical Vector Processing in Go</a> - Introduction to SPMD concepts and <code>reduce</code> operations</li><li><a href=../cross-lane-communication/>Cross-Lane Communication</a> - Deep dive into advanced SPMD patterns and race condition solutions</li><li><a href=https://github.com/golang/go/blob/master/src/net/netip/netip.go>Go&rsquo;s net/netip package</a> - The traditional IPv4 parsing implementation</li></ul><ul class=pa0><li class="list di"><a href=/tags/golang/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Golang</a></li><li class="list di"><a href=/tags/performance/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Performance</a></li><li class="list di"><a href=/tags/networking/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">Networking</a></li><li class="list di"><a href=/tags/simd/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">SIMD</a></li><li class="list di"><a href=/tags/spmd/ class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">SPMD</a></li></ul><div class="mt6 instapaper_ignoref"><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//bluebugs.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><div id=commento></div><script defer src=https://cdn.commento.io/js/commento.js></script></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=http://bluebugs.github.io/>&copy; Cedric Bail 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>