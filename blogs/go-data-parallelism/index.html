<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Data Parallelism: simpler solution for Golang? | Cedric Bail</title>
<meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Why Data Parallelism Matters in Go
Go is a fast language, but it lacks easy ways to express data parallelism and does not provide direct access to low-level SIMD (Single Instruction Multiple Data) instructions. As a result, standard libraries like base64, hex, utf8, json, jpeg, and map are slower than expected. Other ecosystems are more likely to adopt specialized, high-performance libraries, which is why, in some cases, for example, Node.js can outperform Go.
The solution to this bottleneck is for the Go compiler to generate SIMD instructions. There are three main approaches to enabling SIMD in programming languages:"><meta name=generator content="Hugo 0.136.0"><meta name=robots content="index, follow"><meta name=author content="Cedric Bail"><link rel=stylesheet href=/ananke/css/main.min.b27b18f294c9951b5b631d08d9733f0d7794f951b8e49cdde160a91f5a65f320.css><link rel=canonical href=http://bluebugs.github.io/blogs/go-data-parallelism/><meta property="og:url" content="http://bluebugs.github.io/blogs/go-data-parallelism/"><meta property="og:site_name" content="Cedric Bail"><meta property="og:title" content="Data Parallelism: simpler solution for Golang?"><meta property="og:description" content="Why Data Parallelism Matters in Go Go is a fast language, but it lacks easy ways to express data parallelism and does not provide direct access to low-level SIMD (Single Instruction Multiple Data) instructions. As a result, standard libraries like base64, hex, utf8, json, jpeg, and map are slower than expected. Other ecosystems are more likely to adopt specialized, high-performance libraries, which is why, in some cases, for example, Node.js can outperform Go.
The solution to this bottleneck is for the Go compiler to generate SIMD instructions. There are three main approaches to enabling SIMD in programming languages:"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2025-06-19T18:48:59-07:00"><meta property="article:modified_time" content="2025-06-19T18:48:59-07:00"><meta itemprop=name content="Data Parallelism: simpler solution for Golang?"><meta itemprop=description content="Why Data Parallelism Matters in Go Go is a fast language, but it lacks easy ways to express data parallelism and does not provide direct access to low-level SIMD (Single Instruction Multiple Data) instructions. As a result, standard libraries like base64, hex, utf8, json, jpeg, and map are slower than expected. Other ecosystems are more likely to adopt specialized, high-performance libraries, which is why, in some cases, for example, Node.js can outperform Go.
The solution to this bottleneck is for the Go compiler to generate SIMD instructions. There are three main approaches to enabling SIMD in programming languages:"><meta itemprop=datePublished content="2025-06-19T18:48:59-07:00"><meta itemprop=dateModified content="2025-06-19T18:48:59-07:00"><meta itemprop=wordCount content="1570"><meta name=twitter:card content="summary"><meta name=twitter:title content="Data Parallelism: simpler solution for Golang?"><meta name=twitter:description content="Why Data Parallelism Matters in Go Go is a fast language, but it lacks easy ways to express data parallelism and does not provide direct access to low-level SIMD (Single Instruction Multiple Data) instructions. As a result, standard libraries like base64, hex, utf8, json, jpeg, and map are slower than expected. Other ecosystems are more likely to adopt specialized, high-performance libraries, which is why, in some cases, for example, Node.js can outperform Go.
The solution to this bottleneck is for the Go compiler to generate SIMD instructions. There are three main approaches to enabling SIMD in programming languages:"></head><body class="ma0 avenir bg-near-white production"><header class="cover bg-center" style=background-image:url(http://bluebugs.github.io/images/banff.jpg)><div class=bg-black-60><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Cedric Bail</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/blogs/ title="Blog page">Blog</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/examples/ title="Code Examples page">Code Examples</a></li></ul><div class=ananke-socials></div></div></div></nav><div class="tc-l pv6 ph3 ph4-ns"><div class="f2 f1-l fw2 white-90 mb0 lh-title">Data Parallelism: simpler solution for Golang?</div></div></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Blog</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Data Parallelism: simpler solution for Golang?</h1><p class=tracked>By <strong>Cedric Bail</strong></p><time class="f6 mv4 dib tracked" datetime=2025-06-19T18:48:59-07:00>June 19, 2025</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links black pr4-l w-two-thirds-l"><h2 id=why-data-parallelism-matters-in-go>Why Data Parallelism Matters in Go</h2><p>Go is a fast language, but it lacks easy ways to express data parallelism and does not provide direct access to low-level <strong>SIMD</strong> (Single Instruction Multiple Data) instructions. As a result, standard libraries like <a href=https://github.com/golang/go/issues/19636>base64</a>, <a href=https://github.com/golang/go/issues/68188>hex</a>, <a href=https://github.com/golang/go/issues/63347>utf8</a>, <a href=https://github.com/golang/go/issues/53178>json</a>, <a href=https://github.com/golang/go/issues/24499>jpeg</a>, and <a href=https://github.com/golang/go/issues/71255>map</a> are slower than expected. Other ecosystems are more likely to adopt specialized, high-performance libraries, which is why, in some cases, for example, Node.js can outperform Go.</p><p>The solution to this bottleneck is for the Go compiler to generate SIMD instructions. There are three main approaches to enabling SIMD in programming languages:</p><ol><li><p><strong>Automatic Vectorization:</strong> Relying on the compiler to automatically generate SIMD instructions. Despite decades of research, this approach rarely delivers significant performance gains, and developers still write assembly code for critical sections to have reliable outcome.</p></li><li><p><strong>Abstraction Libraries:</strong> Using libraries like <a href=https://github.com/google/highway>Google Highway</a> that provide a higher-level abstraction over SIMD instructions. This approach works well in languages like C++. The current <a href=https://github.com/golang/go/issues/73787>SIMD proposal</a> for Go follows this idea, with code examples like <a href=https://github.com/AndrewHarrisSPU/simd-demo-0/blob/main/sigmoid_simd.go>this</a>.</p></li><li><p><strong>Language-Level Support:</strong> Integrating data parallelism directly into the language, as seen in GPU-oriented languages (e.g., CUDA, OpenGL shaders) and more classical languages like <a href=https://ispc.github.io/ispc.html>ISPC</a>, close to C, and <a href=https://docs.modular.com/mojo/>Mojo</a>, close to Python. This approach makes data parallelism in the code base more readable and maintainable.</p></li></ol><h2 id=what-if-go-made-data-parallelism-simpler>What if Go Made Data Parallelism Simpler?</h2><p>I believe that integrating data parallelism as a core language feature would make Go code faster, but keep its accessibility, readability, and portability. In this blog, I will explore what it might look like to add data parallelism to Go, inspired by languages like ISPC and Mojo. Even if Go never adopts this approach, understanding these concepts can help you write better compute kernels or Mojo code.</p><p>The key feature missing in Go is the ability to express that we can manipulate data in parallel in a certain block of code. While Go supports concurrent function execution with the <strong><code>go</code></strong> keyword, it focus only on code flow level parallelism. Languages like ISPC use <strong><code>foreach</code></strong>, and Mojo uses <strong><code>vectorize</code></strong> to express this. Both enable the same code to run on CPUs and GPUs.</p><p>This model is called <strong>SPMD</strong> (Single Program Multiple Data). Unlike languages like C#, Zig, or Rust, which offer only high-level abstractions or low-level primitives, SPMD lets developers explicitly write code that can be parallelized mechanically.</p><h2 id=lets-go-for-it>Let&rsquo;s <code>go for it</code></h2><p>How could we express data parallelism in Go? Currently, Go does not annotate functions as thread-safe; we simply use <strong><code>go</code></strong> to run them concurrently. Similarly, we could extend the <strong><code>go</code></strong> keyword with <strong><code>for</code></strong> to indicate data parallelism, e.g., <strong><code>go for</code></strong>. This would not break existing code, as <strong><code>go</code></strong> is currently only followed by a function call.</p><p>Before diving into examples, let&rsquo;s define some vocabulary:</p><ul><li><strong><code>varying</code></strong>: Represents a SIMD register containing multiple values, one per &ldquo;lane&rdquo;.</li><li><strong><code>lane</code></strong>: Each value in a SIMD register.</li><li><strong><code>mask</code></strong>: Used to enable or disable lanes during computation.</li><li><strong><code>uniform</code></strong>: A variable with the same value across all lanes, aka a normal variable like all the variable you have in Go today.</li></ul><p>We use <strong><code>varying</code></strong> to indicate types that hold multiple values (across lanes), and <strong><code>uniform</code></strong> for single values. Inside a <strong><code>go for</code></strong> loop, you might need to declare variables as <strong><code>uniform</code></strong> for optimization or compatibility.</p><h2 id=simple-example>Simple Example</h2><p>An example is always better than a long discourse. Let start with the following example to demonstrates a simple sum operation using data parallelism:</p><style>#spmd-demo_sum{display:flex;flex-direction:column;font-family:sans-serif;border:1px solid #ccc;padding:10px;max-width:900px;margin:20px auto;background-color:#f9f9f9;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,.1)}#spmd-code-pane_sum{flex:1;padding:15px;background-color:#fff;border-right:1px solid #eee;border-radius:4px 0 0 4px}#spmd-info-pane_sum{padding:10px;font-size:.9em;color:#333;text-align:left;width:100%;background-color:#fff;border:1px solid #eee;border-radius:4px}#spmd-info-pane_sum h4{margin-top:0;color:#555}#spmd-viz-pane_sum{flex:1.5;padding:15px;display:flex;flex-direction:column;align-items:center}#spmd-lane-data-grid_sum{display:grid;grid-template-columns:auto repeat(4,1fr);gap:5px 8px;width:100%;margin-bottom:20px;align-items:center}#spmd-lane-data-grid_sum .spmd-grid-cell[id*=-v]{color:#28a745;font-weight:700}#spmd-lane-data-grid_sum .spmd-grid-cell[id*=-s]{color:#007bff;font-weight:700}#spmd-controls_sum{margin-top:20px;text-align:center}</style><div id=spmd-demo_sum><div id=spmd-main-content_sum class=spmd-demo><div id=spmd-code-pane_sum class=spmd-code-pane><pre><code id=spmd-go-code_sum> 
<span class=code-line data-line=1><span class=gokw>func</span> <span class=gofn>sum</span><span class=gopunct>(</span><span class=govar>a</span> <span class=goty>[]int</span><span class=gopunct>)</span> <span class=goty>int</span> <span class=gopunct>{</span></span>
<span class=code-line data-line=2>    <span class=gokw>var</span> <span class=govar>s</span> <span class=gohypo>varying</span> <span class=goty>int</span></span>
<span class=code-line data-line=3>    <span class=gokw>go</span> <span class=gokw>for</span> <span class=govar>_</span><span class=gopunct>,</span> <span class=govar>v</span> <span class=goop>:=</span> <span class=gokw>range</span> <span class=govar>a</span> <span class=gopunct>{</span></span>
<span class=code-line data-line=4>        <span class=govar>s</span> <span class=goop>+=</span> <span class=govar>v</span></span>
<span class=code-line data-line=5>    <span class=gopunct>}</span></span>
<span class=code-line data-line=6>    <span class=gokw>return</span> <span class=gofn>reduce.Add</span><span class=gopunct>(</span><span class=govar>s</span><span class=gopunct>)</span></span>
<span class=code-line data-line=7><span class=gopunct>}</span></span>
    </code></pre></div><div id=spmd-viz-pane_sum class=spmd-viz-pane><div id=spmd-lane-data-grid_sum class=spmd-lane-data-grid><div class=spmd-grid-label></div><div class=spmd-grid-header>Lane 1</div><div class=spmd-grid-header>Lane 2</div><div class=spmd-grid-header>Lane 3</div><div class=spmd-grid-header>Lane 4</div><div class=spmd-grid-label>v:</div><div class=spmd-grid-cell id=spmd-lane-0-v_sum>-</div><div class=spmd-grid-cell id=spmd-lane-1-v_sum>-</div><div class=spmd-grid-cell id=spmd-lane-2-v_sum>-</div><div class=spmd-grid-cell id=spmd-lane-3-v_sum>-</div><div class=spmd-grid-label>s:</div><div class=spmd-grid-cell id=spmd-lane-0-s_sum>0</div><div class=spmd-grid-cell id=spmd-lane-1-s_sum>0</div><div class=spmd-grid-cell id=spmd-lane-2-s_sum>0</div><div class=spmd-grid-cell id=spmd-lane-3-s_sum>0</div></div><div id=spmd-final-result_sum class=spmd-final-result><h4>Final Result</h4><div class=result-lines-container><div class=result-line><span class=spmd-result-label>reduce.Add:</span>
<span class=spmd-result-value-group><span id=spmd-summation-expression_sum class=spmd-summation-text></span> <span class=spmd-equals-sign id=spmd-equals-sign_sum style=display:none>=</span> <span id=spmd-final-result-value_sum class=spmd-final-value-text>N/A</span></span></div></div></div><div id=spmd-controls_sum class=spmd-controls><button id=spmd-prev-step_sum>Previous</button>
<button id=spmd-next-step_sum>Next</button></div></div></div><div id=spmd-info-pane_sum class=spmd-info-pane><h4>Execution Step:</h4><p id=spmd-step-description_sum>Initialize `a` with `[]int{1,2,3,4,5,6}`. Four execution lanes available.</p></div></div><script>document.addEventListener("DOMContentLoaded",()=>{const d=document.querySelectorAll("#spmd-go-code_sum .code-line"),h=document.getElementById("spmd-step-description_sum"),u=[document.getElementById("spmd-lane-0-v_sum"),document.getElementById("spmd-lane-1-v_sum"),document.getElementById("spmd-lane-2-v_sum"),document.getElementById("spmd-lane-3-v_sum")],c=[document.getElementById("spmd-lane-0-s_sum"),document.getElementById("spmd-lane-1-s_sum"),document.getElementById("spmd-lane-2-s_sum"),document.getElementById("spmd-lane-3-s_sum")],o=document.getElementById("spmd-final-result-value_sum"),i=document.getElementById("spmd-summation-expression_sum"),a=document.getElementById("spmd-equals-sign_sum"),r=document.getElementById("spmd-prev-step_sum"),s=document.getElementById("spmd-next-step_sum"),l=4,n=[{line:null,description:"Calling <span class='spmd-inline-code'><span class='gofn'>sum</span><span class='gopunct'>(</span><span class='goty'>[]int</span><span class='gopunct'>{</span>1,2,3,4,5,6<span class='gopunct'>}</span><span class='gopunct'>)</span></span> which initializes <span class='spmd-inline-code'><span class='govar'>a</span> = <span class='goty'>[]int</span><span class='gopunct'>{</span>1,2,3,4,5,6<span class='gopunct'>}</span></span>.",laneVDisplay:["-","-","-","-"],laneSDisplay:[0,0,0,0],finalResult:"N/A"},{line:2,description:"<span class='spmd-inline-code'><span class='gokw'>var</span> <span class='govar'>s</span> <span class='gohypo'>varying</span> <span class='goty'>int</span></span>: Each lane gets its own <span class='spmd-inline-code'><span class='govar'>s</span></span> initialized to 0.",laneVDisplay:["-","-","-","-"],laneSDisplay:[0,0,0,0],finalResult:"N/A"},{line:3,description:"Next, <span class='spmd-inline-code'><span class='gokw'>go</span> <span class='gokw'>for</span> <span class='govar'>_</span><span class='gopunct'>,</span> <span class='govar'>v</span> <span class='goop'>:=</span> <span class='gokw'>range</span> <span class='govar'>a</span></span> distributes the first batch of data: <span class='spmd-inline-code'><span class='govar'>v</span>=1</span> to Lane 1, <span class='spmd-inline-code'><span class='govar'>v</span>=2</span> to Lane 2, <span class='spmd-inline-code'><span class='govar'>v</span>=3</span> to Lane 3, and <span class='spmd-inline-code'><span class='govar'>v</span>=4</span> to Lane 4.",laneVDisplay:[1,2,3,4],laneSDisplay:[0,0,0,0],finalResult:"N/A"},{line:4,description:"Then, <span class='spmd-inline-code'><span class='govar'>s</span> <span class='goop'>+=</span> <span class='govar'>v</span></span> executes. For lanes 1, 2, 3, and 4, the current value of <span class='spmd-inline-code'><span class='govar'>s</span></span> (which is 0 for all) is added to their assigned <span class='spmd-inline-code'><span class='govar'>v</span></span>. The result is stored back in <span class='spmd-inline-code'><span class='govar'>s</span></span> for each lane.",laneVDisplay:[1,2,3,4],laneSDisplay:[1,2,3,4],finalResult:"N/A"},{line:3,description:"The <span class='spmd-inline-code'><span class='gokw'>go</span> <span class='gokw'>for</span></span> loop continues, distributing the next batch: <span class='spmd-inline-code'><span class='govar'>v</span>=5</span> to Lane 1 and <span class='spmd-inline-code'><span class='govar'>v</span>=6</span> to Lane 2. Lanes 3 and 4 are idle for new <span class='spmd-inline-code'><span class='govar'>v</span></span> assignments as there's no more data for them.",laneVDisplay:[5,6,"-","-"],laneSDisplay:[1,2,3,4],finalResult:"N/A"},{line:4,description:"<span class='spmd-inline-code'><span class='govar'>s</span> <span class='goop'>+=</span> <span class='govar'>v</span></span> executes again. For lanes 1 and 2, their current <span class='spmd-inline-code'><span class='govar'>s</span></span> is added to their new <span class='spmd-inline-code'><span class='govar'>v</span></span>. Lane 1: <span class='spmd-inline-code'>1 + 5 = 6</span>. Lane 2: <span class='spmd-inline-code'>2 + 6 = 8</span>. The <span class='spmd-inline-code><span class='govar'>s</span></span> values for Lanes 3 and 4 remain unchanged.",laneVDisplay:[5,6,"-","-"],laneSDisplay:[1+5,2+6,3,4],finalResult:"N/A"},{line:5,description:"The loop finishes as all elements from <span class='spmd-inline-code'><span class='govar'>a</span></span> have been processed. The <span class='spmd-inline-code'><span class='govar'>s</span></span> values in each lane are now: Lane 1: 6, Lane 2: 8, Lane 3: 3, Lane 4: 4.",laneVDisplay:["-","-","-","-"],laneSDisplay:[6,8,3,4],finalResult:"N/A"},{line:6,description:"Finally, <span class='spmd-inline-code'><span class='gokw'>return</span> <span class='gofn'>reduce.Add</span><span class='gopunct'>(</span><span class='govar'>s</span><span class='gopunct'>)</span></span> aggregates the <span class='spmd-inline-code'><span class='govar'>s</span></span> values from all lanes: <span class='spmd-inline-code'>6 + 8 + 3 + 4 = 21</span>.",laneVDisplay:["-","-","-","-"],laneSDisplay:[6,8,3,4],finalResult:21},{line:7,description:"The function returns the total sum: <span class='spmd-inline-code'>21</span>.",laneVDisplay:["-","-","-","-"],laneSDisplay:[6,8,3,4],finalResult:21}];let e=0;function t(e){const t=n[e];if(d.forEach(e=>e.classList.remove("highlight")),t.line!==null){const e=document.querySelector(`#spmd-go-code_sum .code-line[data-line="${t.line}"]`);e&&e.classList.add("highlight")}h.innerHTML=t.description;for(let e=0;e<l;e++)u[e].textContent=t.laneVDisplay[e],c[e].textContent=t.laneSDisplay[e];if(t.finalResult!=="N/A"){const e=t.laneSDisplay.filter(e=>typeof e=="number");i.textContent=e.join(" + "),a.style.display="inline",o.textContent=t.finalResult}else i.textContent="",a.style.display="none",o.textContent="N/A";r.disabled=e===0,s.disabled=e===n.length-1}r.addEventListener("click",()=>{e>0&&(e--,t(e))}),s.addEventListener("click",()=>{e<n.length-1&&(e++,t(e))}),t(e)})</script><p>Here, we declare a variables <strong><code>s</code></strong> as <strong><code>varying</code></strong> to operate on multiple data points in parallel. At the end of the loop, we use a <strong><code>reduce</code></strong> function to combine the results from all lanes into a single value. Libraries like <a href=https://ispc.github.io/ispc.html#reductions>ISPC</a> and <a href=https://docs.modular.com/mojo/stdlib/algorithm/reduction/>Mojo</a> provide a variety of reduction functions, which could inspire a similar package in Go.</p><p>With this example, we also show how the mask can be used. If there is no data to be manipulated, the compiler can use a mask to ignore some lanes and just move on. There is no requirement on the compiler for how to implement this. ISPC and Mojo have shown that this model can match a wide range of hardware, while CUDA, OpenCL and friends have shown it deliver well on GPU. It also leaves a lot of freedom to the compiler on how to implement it. This is just a mental model of what a pseudo compiler would do.</p><h2 id=how-would-_if_-work>How Would <em>if</em> Work?</h2><p>We can extend the masking concept to implement conditional logic (<strong><code>if</code></strong> statements) in data-parallel code:</p><style>#spmd-demo_oddeven{display:flex;flex-direction:column;font-family:sans-serif;border:1px solid #ccc;padding:10px;max-width:900px;margin:20px auto;background-color:#f9f9f9;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,.1)}#spmd-code-pane_oddeven{flex:1;padding:15px;background-color:#fff;border-right:1px solid #eee;border-radius:4px 0 0 4px}#spmd-info-pane_oddeven{padding:10px;font-size:.9em;color:#333;text-align:left;width:100%;background-color:#fff;border:1px solid #eee;border-radius:4px}#spmd-viz-pane_oddeven{flex:1.5;padding:15px;display:flex;flex-direction:column;align-items:center}#spmd-lane-data-grid_oddeven{display:grid;grid-template-columns:auto repeat(4,1fr);gap:5px 8px;width:100%;margin-bottom:20px;align-items:center}#spmd-lane-data-grid_oddeven .spmd-grid-cell[id*=-v]{color:#28a745;font-weight:700}#spmd-lane-data-grid_oddeven .spmd-grid-cell[id*=-odd],#spmd-lane-data-grid_oddeven .spmd-grid-cell[id*=-even]{color:#007bff;font-weight:700}#spmd-lane-data-grid_oddeven .spmd-grid-cell.inactive-lane{background-color:#e9ecef;color:#adb5bd;font-style:italic}#spmd-controls_oddeven{margin-top:20px;text-align:center}</style><div id=spmd-demo_oddeven><div id=spmd-main-content_oddeven class=spmd-demo><div id=spmd-code-pane_oddeven class="spmd-code-pane spmd-code-pane-oddeven"><pre><code id=spmd-go-code_oddeven> 
<span class=code-line data-line=1><span class=gokw>func</span> <span class=gofn>oddEvenCount</span><span class=gopunct>(</span><span class=govar>a</span> <span class=goty>[]int</span><span class=gopunct>)</span> <span class=gopunct>(</span><span class=goty>int</span><span class=gopunct>,</span> <span class=goty>int</span><span class=gopunct>)</span> <span class=gopunct>{</span></span>
<span class=code-line data-line=2>  <span class=gokw>var</span> <span class=govar>odd</span> <span class=gohypo>varying</span> <span class=goty>int</span></span>
<span class=code-line data-line=3>  <span class=gokw>var</span> <span class=govar>even</span> <span class=gohypo>varying</span> <span class=goty>int</span></span>
<span class=code-line data-line=4>  <span class=gokw>go</span> <span class=gokw>for</span> <span class=govar>_</span><span class=gopunct>,</span> <span class=govar>v</span> <span class=goop>:=</span> <span class=gokw>range</span> <span class=govar>a</span> <span class=gopunct>{</span></span>
<span class=code-line data-line=5>    <span class=gokw>if</span> <span class=govar>v</span><span class=goop>&amp;</span><span class=gonum>1</span> <span class=goop>==</span> <span class=gonum>1</span> <span class=gopunct>{</span> <span class=gocomment>// Check if odd</span></span>
<span class=code-line data-line=6>        <span class=govar>odd</span><span class=goop>++</span></span>
<span class=code-line data-line=7>    <span class=gopunct>}</span> <span class=gokw>else</span> <span class=gopunct>{</span>      <span class=gocomment>// Else it's even</span></span>
<span class=code-line data-line=8>        <span class=govar>even</span><span class=goop>++</span></span>
<span class=code-line data-line=9>    <span class=gopunct>}</span></span>
<span class=code-line data-line=10>  <span class=gopunct>}</span></span>
<span class=code-line data-line=11>  <span class=gokw>return</span> <span class=gofn>reduce.Add</span><span class=gopunct>(</span><span class=govar>odd</span><span class=gopunct>),</span> <span class=gofn>reduce.Add</span><span class=gopunct>(</span><span class=govar>even</span><span class=gopunct>)</span></span>
<span class=code-line data-line=12><span class=gopunct>}</span></span>
    </code></pre></div><div id=spmd-viz-pane_oddeven class=spmd-viz-pane><div id=spmd-lane-data-grid_oddeven><div class=spmd-grid-label></div><div class=spmd-grid-header>Lane 1</div><div class=spmd-grid-header>Lane 2</div><div class=spmd-grid-header>Lane 3</div><div class=spmd-grid-header>Lane 4</div><div class=spmd-grid-label>mask:</div><div class=spmd-grid-cell id=spmd-lane-1-mask_oddeven>-</div><div class=spmd-grid-cell id=spmd-lane-2-mask_oddeven>-</div><div class=spmd-grid-cell id=spmd-lane-3-mask_oddeven>-</div><div class=spmd-grid-cell id=spmd-lane-4-mask_oddeven>-</div><div class=spmd-grid-label>v:</div><div class=spmd-grid-cell id=spmd-lane-0-v_oddeven>-</div><div class=spmd-grid-cell id=spmd-lane-1-v_oddeven>-</div><div class=spmd-grid-cell id=spmd-lane-2-v_oddeven>-</div><div class=spmd-grid-cell id=spmd-lane-3-v_oddeven>-</div><div class=spmd-grid-label>odd:</div><div class=spmd-grid-cell id=spmd-lane-0-odd_oddeven>0</div><div class=spmd-grid-cell id=spmd-lane-1-odd_oddeven>0</div><div class=spmd-grid-cell id=spmd-lane-2-odd_oddeven>0</div><div class=spmd-grid-cell id=spmd-lane-3-odd_oddeven>0</div><div class=spmd-grid-label>even:</div><div class=spmd-grid-cell id=spmd-lane-0-even_oddeven>0</div><div class=spmd-grid-cell id=spmd-lane-1-even_oddeven>0</div><div class=spmd-grid-cell id=spmd-lane-2-even_oddeven>0</div><div class=spmd-grid-cell id=spmd-lane-3-even_oddeven>0</div></div><div id=spmd-final-result_oddeven><h4>Final Results</h4><div class=result-lines-container><div class=result-line><span class=spmd-result-label>Total Odd:</span>
<span class=spmd-result-value-group><span id=spmd-odd-summation_oddeven class=spmd-summation-text></span>
<span class=spmd-equals-sign id=spmd-odd-equals-sign_oddeven style=display:none>=</span> <span id=spmd-odd-final-value_oddeven class=spmd-final-value-text>N/A</span></span></div><div class=result-line><span class=spmd-result-label>Total Even:</span>
<span class=spmd-result-value-group><span id=spmd-even-summation_oddeven class=spmd-summation-text></span>
<span class=spmd-equals-sign id=spmd-even-equals-sign_oddeven style=display:none>=</span> <span id=spmd-even-final-value_oddeven class=spmd-final-value-text>N/A</span></span></div></div></div><div id=spmd-controls_oddeven class=spmd-controls><button id=spmd-prev-step_oddeven>Previous</button>
<button id=spmd-next-step_oddeven>Next</button></div></div></div><div id=spmd-info-pane_oddeven class=spmd-info-pane><h4>Execution Step:</h4><p id=spmd-step-description_oddeven>Initializing...</p></div></div><script>document.addEventListener("DOMContentLoaded",()=>{const m=document.querySelectorAll("#spmd-go-code_oddeven .code-line"),v=document.getElementById("spmd-step-description_oddeven"),h=[document.getElementById("spmd-lane-1-mask_oddeven"),document.getElementById("spmd-lane-2-mask_oddeven"),document.getElementById("spmd-lane-3-mask_oddeven"),document.getElementById("spmd-lane-4-mask_oddeven")],d=[document.getElementById("spmd-lane-0-v_oddeven"),document.getElementById("spmd-lane-1-v_oddeven"),document.getElementById("spmd-lane-2-v_oddeven"),document.getElementById("spmd-lane-3-v_oddeven")],u=[document.getElementById("spmd-lane-0-odd_oddeven"),document.getElementById("spmd-lane-1-odd_oddeven"),document.getElementById("spmd-lane-2-odd_oddeven"),document.getElementById("spmd-lane-3-odd_oddeven")],l=[document.getElementById("spmd-lane-0-even_oddeven"),document.getElementById("spmd-lane-1-even_oddeven"),document.getElementById("spmd-lane-2-even_oddeven"),document.getElementById("spmd-lane-3-even_oddeven")],o=document.getElementById("spmd-odd-summation_oddeven"),i=document.getElementById("spmd-odd-final-value_oddeven"),n=document.getElementById("spmd-even-summation_oddeven"),s=document.getElementById("spmd-even-final-value_oddeven"),g=[document.getElementById("spmd-odd-equals-sign_oddeven"),document.getElementById("spmd-even-equals-sign_oddeven")],a=document.getElementById("spmd-prev-step_oddeven"),t=document.getElementById("spmd-next-step_oddeven"),f=4,p=[1,2,3,4,5,6,7],c=[{line:null,description:`Calling <span class='spmd-inline-code'><span class='gofn'>oddEvenCount</span><span class='gopunct'>(</span><span class='goty'>[]int</span><span class='gopunct'{>{</span>${p.join(",")}<span class='gopunct'>}</span><span class='gopunct'>)</span></span>. Input <span class='spmd-inline-code'><span class='govar'>a</span></span> is initialized. Four execution lanes available.`,laneMaskDisplay:[!0,!0,!0,!0],laneVDisplay:["-","-","-","-"],laneOddDisplay:[0,0,0,0],laneEvenDisplay:[0,0,0,0],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:2,description:"<span class='spmd-inline-code'><span class='gokw'>var</span> <span class='govar'>odd</span> <span class='gohypo'>varying</span> <span class='goty'>int</span></span>: Each lane gets its own <span class='spmd-inline-code'><span class='govar'>odd</span></span> counter, initialized to 0.",laneMaskDisplay:[!0,!0,!0,!0],laneVDisplay:["-","-","-","-"],laneOddDisplay:[0,0,0,0],laneEvenDisplay:[0,0,0,0],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:3,description:"<span class='spmd-inline-code'><span class='gokw'>var</span> <span class='govar'>even</span> <span class='gohypo'>varying</span> <span class='goty'>int</span></span>: Each lane gets its own <span class='spmd-inline-code'><span class='govar'>even</span></span> counter, initialized to 0.",laneMaskDisplay:[!0,!0,!0,!0],laneVDisplay:["-","-","-","-"],laneOddDisplay:[0,0,0,0],laneEvenDisplay:[0,0,0,0],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:4,description:"<span class='spmd-inline-code'><span class='gokw'>go</span> <span class='gokw'>for</span> <span class='govar'>_</span><span class='gopunct'>,</span> <span class='govar'>v</span> <span class='goop'>:=</span> <span class='gokw'>range</span> <span class='govar'>a</span></span>: Distributing first batch. <span class='spmd-inline-code'><span class='govar'>v</span>=1</span> (L1), <span class='spmd-inline-code'><span class='govar'>v</span>=2</span> (L2), <span class='spmd-inline-code'><span class='govar'>v</span>=3</span> (L3), <span class='spmd-inline-code'><span class='govar'>v</span>=4</span> (L4).",laneMaskDisplay:[!0,!0,!0,!0],laneVDisplay:[1,2,3,4],laneOddDisplay:[0,0,0,0],laneEvenDisplay:[0,0,0,0],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:5,description:"Evaluating <span class='spmd-inline-code'><span class='gokw'>if</span> <span class='govar'>v</span><span class='goop'>&amp;</span>1 <span class='goop'>==</span> 1</span>. L1 (<span class='spmd-inline-code'>1</span>) is odd (mask=true). L2 (<span class='spmd-inline-code'>2</span>) is even (mask=false). L3 (<span class='spmd-inline-code'>3</span>) is odd (mask=true). L4 (<span class='spmd-inline-code'>4</span>) is even (mask=false).",laneMaskDisplay:[!0,!1,!0,!1],laneVDisplay:[1,2,3,4],laneOddDisplay:[0,0,0,0],laneEvenDisplay:[0,0,0,0],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:6,description:"Executing <span class='spmd-inline-code'><span class='govar'>odd</span><span class='goop'>++</span></span> for lanes where condition was true. L1: <span class='spmd-inline-code'><span class='govar'>odd</span></span> becomes 1. L3: <span class='spmd-inline-code'><span class='govar'>odd</span></span> becomes 1.",laneMaskDisplay:[!0,!1,!0,!1],laneVDisplay:[1,2,3,4],laneOddDisplay:[1,0,1,0],laneEvenDisplay:[0,0,0,0],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:7,description:"Transition to <span class='spmd-inline-code'><span class='gokw'>else</span></span> block. L2 and L4 will execute <span class='spmd-inline-code'><span class='govar'>even</span><span class='goop'>++</span></span>.",laneMaskDisplay:[!1,!0,!1,!0],laneVDisplay:[1,2,3,4],laneOddDisplay:[1,0,1,0],laneEvenDisplay:[0,0,0,0],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:8,description:"Executing <span class='spmd-inline-code'><span class='govar'>even</span><span class='goop'>++</span></span> for lanes in the <span class='spmd-inline-code'><span class='gokw'>else</span></span> block. L2: <span class='spmd-inline-code'><span class='govar'>even</span></span> becomes 1. L4: <span class='spmd-inline-code'><span class='govar'>even</span></span> becomes 1.",laneMaskDisplay:[!1,!0,!1,!0],laneVDisplay:[1,2,3,4],laneOddDisplay:[1,0,1,0],laneEvenDisplay:[0,1,0,1],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:9,description:"Finished <span class='spmd-inline-code'><span class='gokw'>if</span><span class='goop'>/</span><span class='gokw'>else</span></span> block for the first set of values. All lanes active for next iteration.",laneMaskDisplay:[!0,!0,!0,!0],laneVDisplay:[1,2,3,4],laneOddDisplay:[1,0,1,0],laneEvenDisplay:[0,1,0,1],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:4,description:"<span class='spmd-inline-code'><span class='gokw'>go</span> <span class='gokw'>for</span></span>: Distributing next batch. <span class='spmd-inline-code'><span class='govar'>v</span>=5</span> (L1), <span class='spmd-inline-code'><span class='govar'>v</span>=6</span> (L2), <span class='spmd-inline-code'><span class='govar'>v</span>=7</span> (L3). Lane 4 is idle for data processing in this batch.",laneMaskDisplay:[!0,!0,!0,!1],laneVDisplay:[5,6,7,"-"],laneOddDisplay:[1,0,1,0],laneEvenDisplay:[0,1,0,1],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:5,description:"Evaluating <span class='spmd-inline-code'><span class='gokw'>if</span> <span class='govar'>v</span><span class='goop'>&amp;</span>1 <span class='goop'>==</span> 1</span>. L1 (<span class='spmd-inline-code'>5</span>) is odd (mask=true). L2 (<span class='spmd-inline-code'>6</span>) is even (mask=false). L3 (<span class='spmd-inline-code'>7</span>) is odd (mask=true). Lane 4 is idle (mask=false).",laneMaskDisplay:[!0,!1,!0,!1],laneVDisplay:[5,6,7,"-"],laneOddDisplay:[1,0,1,0],laneEvenDisplay:[0,1,0,1],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:6,description:"Executing <span class='spmd-inline-code'><span class='govar'>odd</span><span class='goop'>++</span></span>. L1: <span class='spmd-inline-code'><span class='govar'>odd</span></span> becomes 2 (1+1). L3: <span class='spmd-inline-code'><span class='govar'>odd</span></span> becomes 2 (1+1). Lane 4 idle.",laneMaskDisplay:[!0,!1,!0,!1],laneVDisplay:[5,6,7,"-"],laneOddDisplay:[1+1,0,1+1,0],laneEvenDisplay:[0,1,0,1],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:7,description:"Transition to <span class='spmd-inline-code'><span class='gokw'>else</span></span> block. L2 will execute <span class='spmd-inline-code'><span class='govar'>even</span><span class='goop'>++</span></span>. Lane 4 idle.",laneMaskDisplay:[!1,!0,!1,!1],laneVDisplay:[5,6,7,"-"],laneOddDisplay:[2,0,2,0],laneEvenDisplay:[0,1,0,1],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:8,description:"Executing <span class='spmd-inline-code'><span class='govar'>even</span><span class='goop'>++</span></span>. L2: <span class='spmd-inline-code'><span class='govar'>even</span></span> becomes 2 (1+1). Lane 4 idle.",laneMaskDisplay:[!1,!0,!1,!1],laneVDisplay:[5,6,7,"-"],laneOddDisplay:[2,0,2,0],laneEvenDisplay:[0,1+1,0,1],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:9,description:"Finished <span class='spmd-inline-code'><span class='gokw'>if</span><span class='goop'>/</span><span class='gokw'>else</span></span> block for the second set of values. Lane 4 was idle.",laneMaskDisplay:[!0,!0,!0,!1],laneVDisplay:[5,6,7,"-"],laneOddDisplay:[2,0,2,0],laneEvenDisplay:[0,2,0,1],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:10,description:"Loop finished. All elements from <span class='spmd-inline-code'><span class='govar'>a</span></span> have been processed.",laneMaskDisplay:[!0,!0,!0,!0],laneVDisplay:["-","-","-","-"],laneOddDisplay:[2,0,2,0],laneEvenDisplay:[0,2,0,1],finalResultOdd:"N/A",finalResultEven:"N/A"},{line:11,description:"<span class='spmd-inline-code'><span class='gokw'>return</span> <span class='gofn'>reduce.Add</span><span class='gopunct'>(</span><span class='govar'>odd</span><span class='gopunct'>),</span> <span class='gofn'>reduce.Add</span><span class='gopunct'>(</span><span class='govar'>even</span><span class='gopunct'>)</span></span>: Aggregating <span class='spmd-inline-code'><span class='govar'>odd</span></span> values (<span class='spmd-inline-code'>2+0+2+0</span>) and <span class='spmd-inline-code'><span class='govar'>even</span></span> values (<span class='spmd-inline-code'>0+2+0+1</span>) from all lanes.",laneMaskDisplay:[!0,!0,!0,!0],laneVDisplay:["-","-","-","-"],laneOddDisplay:[2,0,2,0],laneEvenDisplay:[0,2,0,1],finalResultOdd:4,finalResultEven:3},{line:12,description:"Function returns total odd count: <span class='spmd-inline-code'>4</span>, total even count: <span class='spmd-inline-code'>3</span>.",laneMaskDisplay:[!0,!0,!0,!0],laneVDisplay:["-","-","-","-"],laneOddDisplay:[2,0,2,0],laneEvenDisplay:[0,2,0,1],finalResultOdd:4,finalResultEven:3}];let e=0;function r(e){const r=c[e];if(m.forEach(e=>e.classList.remove("highlight")),r.line!==null)if(Array.isArray(r.line))r.line.forEach(e=>{const t=document.querySelector(`#spmd-go-code_oddeven .code-line[data-line="${e}"]`);t&&t.classList.add("highlight")});else{const e=document.querySelector(`#spmd-go-code_oddeven .code-line[data-line="${r.line}"]`);e&&e.classList.add("highlight")}v.innerHTML=r.description;for(let e=0;e<f;e++){const t=r.laneMaskDisplay[e];h[e].textContent=t?"true":"false",[d[e],u[e],l[e]].forEach(e=>{e.classList.toggle("inactive-lane",!t)}),d[e].textContent=r.laneVDisplay[e],u[e].textContent=r.laneOddDisplay[e],l[e].textContent=r.laneEvenDisplay[e]}const p=r.finalResultOdd!=="N/A"&&r.finalResultEven!=="N/A";g.forEach(e=>{e&&(e.style.display=p?"inline":"none")}),p?(o&&(o.textContent=r.laneOddDisplay.filter(e=>typeof e=="number"&&!isNaN(e)).join(" + ")),i&&(i.textContent=r.finalResultOdd),n&&(n.textContent=r.laneEvenDisplay.filter(e=>typeof e=="number"&&!isNaN(e)).join(" + ")),s&&(s.textContent=r.finalResultEven)):(o&&(o.textContent=""),i&&(i.textContent="N/A"),n&&(n.textContent=""),s&&(s.textContent="N/A")),a&&(a.disabled=e===0),t&&(t.disabled=e===c.length-1)}a&&a.addEventListener("click",()=>{e>0&&(e--,r(e))}),t&&t.addEventListener("click",()=>{e<c.length-1&&(e++,r(e))}),r(e)})</script><p>This allows us to process data in parallel, with different behavior depending on the data in each lane. The next control flow construct we need is <strong><code>for</code></strong> in the context of data parallelism.</p><h2 id=extending-to-_for_>Extending to <em>for</em></h2><p>Let&rsquo;s look at how <strong><code>for</code></strong> inside a <strong><code>go for</code></strong> SPMD context would work. We&rsquo;ll add a bit of <strong><code>if</code></strong> inside to show that they can be stacked however we want.</p><style>#spmd-demo_countbits{display:flex;flex-direction:column;font-family:sans-serif;border:1px solid #ccc;padding:10px;max-width:900px;margin:20px auto;background-color:#f9f9f9;border-radius:8px;box-shadow:0 2px 4px rgba(0,0,0,.1)}#spmd-code-pane_countbits{flex:1;padding:15px;background-color:#fff;border-right:1px solid #eee;border-radius:4px 0 0 4px;overflow-x:auto}#spmd-info-pane_countbits{padding:10px;font-size:.9em;color:#333;text-align:left;width:100%;background-color:#fff;border:1px solid #eee;border-radius:4px;margin-top:10px}#spmd-info-pane_countbits h4{margin-top:0;color:#555}#spmd-viz-pane_countbits{flex:1.5;padding:15px;display:flex;flex-direction:column;align-items:center}#spmd-lane-data-grid_countbits{display:grid;grid-template-columns:auto repeat(4,1fr);gap:5px 8px;width:100%;margin-bottom:20px;align-items:center}#spmd-demo_countbits .spmd-binary-value{font-size:.7em}#spmd-demo_countbits .spmd-highlighted-bit{color:red;font-weight:700}#spmd-demo_countbits .spmd-grid-header,#spmd-demo_countbits .spmd-grid-label,#spmd-demo_countbits .spmd-grid-cell{padding:4px;text-align:center}#spmd-demo_countbits .spmd-grid-label{font-weight:700;text-align:right}#spmd-demo_countbits .spmd-grid-header{font-weight:700}#spmd-lane-data-grid_countbits .spmd-grid-cell[id*=\'-v\']{color:#28a745;font-weight:700}#spmd-lane-data-grid_countbits .spmd-grid-cell[id*=\'-c\']{color:#007bff;font-weight:700}#spmd-controls_countbits{margin-top:20px;text-align:center}#spmd-controls_countbits button{padding:8px 15px;margin:0 5px;border-radius:4px;border:1px solid #007bff;background-color:#007bff;color:#fff;cursor:pointer}#spmd-controls_countbits button:disabled{background-color:#ccc;border-color:#ccc;cursor:not-allowed}#spmd-demo_countbits .spmd-grid-cell.inactive-lane{background-color:#e9ecef;color:#adb5bd;font-style:italic}#spmd-uniform-values_countbits{margin:20px 0;padding:15px;background-color:#f8f9fa;border:1px solid #dee2e6;border-radius:8px;text-align:center}#spmd-uniform-values_countbits h4{margin-top:0;margin-bottom:15px;color:#495057;font-size:1em}.uniform-values-container{display:flex;justify-content:center;gap:30px;flex-wrap:wrap}.uniform-value-item{display:flex;flex-direction:column;align-items:center;gap:5px}.uniform-label{font-weight:700;color:#6c757d;font-size:.9em}.uniform-value{font-family:monospace;font-size:1.1em;font-weight:700;color:#333;background-color:#fff;padding:8px 12px;border:1px solid #ced4da;border-radius:4px;min-width:80px}</style><div id=spmd-demo_countbits><div id=spmd-main-content_countbits class=spmd-demo><div id=spmd-code-pane_countbits class=spmd-code-pane><pre><code id=spmd-go-code_countbits class=language-go>
<span class=code-line data-line=1><span class=gokw>func</span> <span class=gofn\>countBits</span><span class=gopunct\>(</span><span class=govar\>a</span> <span class=goty>[]byte</span><span class=gopunct\>)</span> <span class=goty>int</span> <span class=gopunct\>{</span></span>
<span class=code-line data-line=2>    <span class=gokw>var</span> <span class=govar>c</span> <span class=gohypo>varying</span> <span class=goty>uint8</span></span>
<span class=code-line data-line=3>    <span class=gokw>go</span> <span class=gokw>for</span> <span class=govar\\\>_</span><span class=gopunct\>,</span> <span class=govar>v</span> <span class=goop>:=</span> <span class=gokw>range</span> <span class=govar>a</span> <span class=gopunct\>{</span></span>
<span class=code-line data-line=4>        <span class=gokw>for</span> <span class=govar>it</span> <span class=goop>:=</span> <span class=gokw>range</span> <span class=gonum>8</span> <span class=gopunct\>{</span></span>
<span class=code-line data-line=5>            <span class=govar>offset</span> <span class=goop>:=</span> <span class=gonum>1</span> <span class=goop>&lt;&lt;</span> <span class=govar>it</span></span>
<span class=code-line data-line=6>            <span class=govar>bitCheck</span> <span class=goop>:=</span> <span class=govar>v</span> <span class=goop>&amp;</span> <span class=govar>offset</span></span>
<span class=code-line data-line=7>            <span class=govar>bitOn</span> <span class=goop>:=</span> <span class=govar>bitCheck</span> <span class=goop>!=</span> <span class=gonum>0</span></span>
<span class=code-line data-line=8>            <span class=gokw>if</span> <span class=govar>bitOn</span> <span class=gopunct\>{</span></span>
<span class=code-line data-line=9>                <span class=govar>c</span><span class=goop>++</span></span>
<span class=code-line data-line=10>            <span class=gopunct\>}</span></span>
<span class=code-line data-line=11>        <span class=gopunct\>}</span></span>
<span class=code-line data-line=12>    <span class=gopunct\>}</span></span>
<span class=code-line data-line=13>    <span class=gokw>return</span> <span class=gofn>reduce.Add</span><span class=gopunct\>(</span><span class=govar>c</span><span class=gopunct\>)</span></span>
<span class=code-line data-line=14><span class=gopunct\>}</span></span>
    </code></pre></div><div id=spmd-viz-pane_countbits class=spmd-viz-pane><div id=spmd-lane-data-grid_countbits class=spmd-lane-data-grid><div class=spmd-grid-label></div><div class=spmd-grid-header>Lane 1</div><div class=spmd-grid-header>Lane 2</div><div class=spmd-grid-header>Lane 3</div><div class=spmd-grid-header>Lane 4</div><div class=spmd-grid-label>mask:</div><div class=spmd-grid-cell id=spmd-lane-0-mask_countbits>-</div><div class=spmd-grid-cell id=spmd-lane-1-mask_countbits>-</div><div class=spmd-grid-cell id=spmd-lane-2-mask_countbits>-</div><div class=spmd-grid-cell id=spmd-lane-3-mask_countbits>-</div><div class=spmd-grid-label>v:</div><div class=spmd-grid-cell id=spmd-lane-0-v_countbits>-</div><div class=spmd-grid-cell id=spmd-lane-1-v_countbits>-</div><div class=spmd-grid-cell id=spmd-lane-2-v_countbits>-</div><div class=spmd-grid-cell id=spmd-lane-3-v_countbits>-</div><div class=spmd-grid-label>c:</div><div class=spmd-grid-cell id=spmd-lane-0-c_countbits>0</div><div class=spmd-grid-cell id=spmd-lane-1-c_countbits>0</div><div class=spmd-grid-cell id=spmd-lane-2-c_countbits>0</div><div class=spmd-grid-cell id=spmd-lane-3-c_countbits>0</div><div class=spmd-grid-label>bitCheck:</div><div class=spmd-grid-cell id=spmd-lane-0-bitCheck_countbits>-</div><div class=spmd-grid-cell id=spmd-lane-1-bitCheck_countbits>-</div><div class=spmd-grid-cell id=spmd-lane-2-bitCheck_countbits>-</div><div class=spmd-grid-cell id=spmd-lane-3-bitCheck_countbits>-</div><div class=spmd-grid-label>bitOn:</div><div class=spmd-grid-cell id=spmd-lane-0-bitOn_countbits>-</div><div class=spmd-grid-cell id=spmd-lane-1-bitOn_countbits>-</div><div class=spmd-grid-cell id=spmd-lane-2-bitOn_countbits>-</div><div class=spmd-grid-cell id=spmd-lane-3-bitOn_countbits>-</div></div><div id=spmd-uniform-values_countbits class=spmd-uniform-values><h4>Uniform Values</h4><div class=uniform-values-container><div class=uniform-value-item><span class=uniform-label>it:</span>
<span id=spmd-it-value_countbits class=uniform-value>-</span></div><div class=uniform-value-item><span class=uniform-label>offset (binary):</span>
<span id=spmd-offset-binary_countbits class=uniform-value>-</span></div></div></div><div id=spmd-final-result_countbits class=spmd-final-result><h4>Final Result</h4><div class=result-lines-container><div class=result-line><span class=spmd-result-label>Total Bit Count:</span>
<span class=spmd-result-value-group><span id=spmd-summation-expression_countbits class=spmd-summation-text></span>
<span class=spmd-equals-sign id=spmd-equals-sign_countbits style=display:none>=</span>
<span id=spmd-final-result-value_countbits class=spmd-final-value-text>N/A</span></span></div></div></div><div id=spmd-controls_countbits class=spmd-controls><button id=spmd-prev-step_countbits>Previous</button>
<button id=spmd-next-step_countbits>Next</button></div></div></div><div id=spmd-info-pane_countbits class=spmd-info-pane><h4>Execution Step:</h4><p id=spmd-step-description_countbits>Initializing visualization...</p></div></div><script>document.addEventListener("DOMContentLoaded",()=>{const x=document.querySelectorAll("#spmd-go-code_countbits .code-line"),E=document.getElementById("spmd-step-description_countbits"),f=[document.getElementById("spmd-lane-0-v_countbits"),document.getElementById("spmd-lane-1-v_countbits"),document.getElementById("spmd-lane-2-v_countbits"),document.getElementById("spmd-lane-3-v_countbits")],g=[document.getElementById("spmd-lane-0-c_countbits"),document.getElementById("spmd-lane-1-c_countbits"),document.getElementById("spmd-lane-2-c_countbits"),document.getElementById("spmd-lane-3-c_countbits")],v=[document.getElementById("spmd-lane-0-bitCheck_countbits"),document.getElementById("spmd-lane-1-bitCheck_countbits"),document.getElementById("spmd-lane-2-bitCheck_countbits"),document.getElementById("spmd-lane-3-bitCheck_countbits")],b=[document.getElementById("spmd-lane-0-bitOn_countbits"),document.getElementById("spmd-lane-1-bitOn_countbits"),document.getElementById("spmd-lane-2-bitOn_countbits"),document.getElementById("spmd-lane-3-bitOn_countbits")],u=[document.getElementById("spmd-lane-0-mask_countbits"),document.getElementById("spmd-lane-1-mask_countbits"),document.getElementById("spmd-lane-2-mask_countbits"),document.getElementById("spmd-lane-3-mask_countbits")],p=document.getElementById("spmd-final-result-value_countbits"),d=document.getElementById("spmd-summation-expression_countbits"),l=document.getElementById("spmd-equals-sign_countbits"),k=document.getElementById("spmd-it-value_countbits"),j=document.getElementById("spmd-offset-binary_countbits"),h=document.getElementById("spmd-prev-step_countbits"),m=document.getElementById("spmd-next-step_countbits"),i=4,a=[1,2,15,255,170,85];function O(e){e=e&255;let t=0;for(let n=0;n<8;n++)(e&1<<n)!==0&&t++;return t}function _(e){return typeof e=="number"?"0x"+e.toString(16).padStart(2,"0").toUpperCase():e}function n(e,t){if(typeof e=="number"){let n=e.toString(2).padStart(8,"0");if(typeof t=="number"&&t>=0&&t<8){const e=7-t;if(e>=0&&e<n.length)return n.substring(0,e)+'<span class="spmd-highlighted-bit">'+n.charAt(e)+"</span>"+n.substring(e+1)}return n}return e}const y=a.map(e=>_(e)).join(","),r=a.reduce((e,t)=>e+O(t),0),s={func:1,varC:2,goFor:3,forItRange:4,offsetAssignment:5,bitCheckAssignment:6,bitOnAssignment:7,ifBitOn:8,cIncrement:9,endInnerLoop:11,endGoFor:12,reduceAdd:13,funcEnd:14};function w(e,t,s,o){let c=[],r=[...s];const a=t.map(e=>e!=="-");c.push({line:o.forItRange,description:`Batch ${e}: Inner loop <span class="spmd-inline-code"><span class="gokw">for</span> <span class="govar">it</span> <span class="goop">:=</span> <span class="gokw">range</span> <span class="gonum">8</span></span> begins. This loop operates on uniform values - <span class="spmd-inline-code"><span class="govar">it</span></span> will have the same value across all lanes in each iteration.`,laneVDisplay:[...t],laneCDisplay:[...r],laneBitCheckDisplay:a.map(e=>e?"-":"-"),laneBitOnDisplay:a.map(e=>e?"-":"-"),laneMaskDisplay:a.map(e=>e?"true":"false"),finalResult:"N/A",uniformIt:"-",uniformOffset:"-"});for(let s=0;s<8;s++){const l=1<<s;let f=a.map(e=>e?l:"-"),u=t.map((e,t)=>a[t]?e&l:"-"),d=t.map((e,t)=>a[t]?(e&l)!==0:"-");c.push({line:o.offsetAssignment,description:`Batch ${e}, <span class="spmd-inline-code"><span class="govar">it</span> <span class="goop"> = </span> <span class="gonum">${s}</span></span>: Calculate <span class="spmd-inline-code"><span class="govar">offset</span> <span class="goop">:=</span> <span class="gonum">1</span> <span class="goop">&lt;&lt;</span> <span class="govar">it</span></span>. Since <span class="spmd-inline-code"><span class="govar">it</span></span> is uniform, <span class="spmd-inline-code"><span class="govar">offset</span></span> is also uniform: <span class="spmd-inline-code"><span class="govar">offset</span> <span class="goop">=</span> ${n(l,s)}</span> (same value for all active lanes).`,laneVDisplay:[...t],laneCDisplay:[...r],laneBitCheckDisplay:a.map(e=>e?"-":"-"),laneBitOnDisplay:a.map(e=>e?"-":"-"),laneMaskDisplay:a.map(e=>e?"true":"false"),finalResult:"N/A",itVal:s,uniformIt:s,uniformOffset:n(l,s)}),c.push({line:o.bitCheckAssignment,description:`Batch ${e}, <span class="spmd-inline-code"><span class="govar">it</span> <span class="goop"> = </span> <span class="gonum">${s}</span></span>: Calculate <span class="spmd-inline-code"><span class="govar">bitCheck</span> <span class="goop">:=</span> <span class="govar">v</span> <span class="goop">&amp;</span> <span class="govar">offset</span></span>. Since <span class="spmd-inline-code"><span class="govar">offset</span></span> is uniform (${n(l,s)}), each lane performs the same bitwise AND operation with its varying <span class="spmd-inline-code"><span class="govar">v</span></span> value.`,laneVDisplay:[...t],laneCDisplay:[...r],laneBitCheckDisplay:[...u],laneBitOnDisplay:a.map(e=>e?"-":"-"),laneMaskDisplay:a.map(e=>e?"true":"false"),finalResult:"N/A",itVal:s,uniformIt:s,uniformOffset:n(l,s)}),c.push({line:o.bitOnAssignment,description:`Batch ${e}, <span class="spmd-inline-code"><span class="govar">it</span> <span class="goop"> = </span> <span class="gonum">${s}</span></span>: Determine <span class="spmd-inline-code"><span class="govar">bitOn</span> <span class="goop">:=</span> <span class="govar">bitCheck</span> <span class="goop">!=</span> <span class="gonum">0</span></span> for active lanes.`,laneVDisplay:[...t],laneCDisplay:[...r],laneBitCheckDisplay:[...u],laneBitOnDisplay:[...d],laneMaskDisplay:a.map(e=>e?"true":"false"),finalResult:"N/A",itVal:s,uniformIt:s,uniformOffset:n(l,s)}),c.push({line:o.ifBitOn,description:`Batch ${e}, <span class="spmd-inline-code"><span class="govar">it</span> <span class="goop"> = </span> <span class="gonum">${s}</span></span>: Conditional <span class="spmd-inline-code"><span class="gokw">if</span> <span class="govar">bitOn</span></span> for active lanes.`,laneVDisplay:[...t],laneCDisplay:[...r],laneBitCheckDisplay:[...u],laneBitOnDisplay:[...d],laneMaskDisplay:a.map(e=>e?"true":"false"),finalResult:"N/A",itVal:s,uniformIt:s,uniformOffset:n(l,s)});let h=[],m=!1;for(let e=0;e<i;e++)a[e]&&d[e]?(r[e]++,m=!0,h.push(`L${e+1}: <span class="spmd-inline-code"><span class="govar">c</span></span> increments to ${r[e]}`)):a[e]&&h.push(`L${e+1}: <span class="spmd-inline-code"><span class="govar">c</span></span> (${r[e]}) unchanged`);c.push({line:o.cIncrement,description:`Batch ${e}, <span class="spmd-inline-code"><span class="govar">it</span> <span class="goop"> = </span> <span class="gonum">${s}</span></span>: ${m?"Executing":"Skipping (or no active lanes had bitOn=true)"} <span class="spmd-inline-code"><span class="govar">c</span><span class="goop">++</span></span>. ${h.join(". ")}.`,laneVDisplay:[...t],laneCDisplay:[...r],laneBitCheckDisplay:[...u],laneBitOnDisplay:[...d],laneMaskDisplay:a.map((e,t)=>e&&d[t]?"true":e?"false":"false"),finalResult:"N/A",itVal:s,uniformIt:s,uniformOffset:n(l,s)})}return c.push({line:o.endInnerLoop,description:`Batch ${e}: Inner loop <span class="spmd-inline-code"><span class="gokw">for</span> <span class="govar">it</span></span> (lines ${o.forItRange}-${o.endInnerLoop}) completes. Final <span class="spmd-inline-code"><span class="govar">c</span></span> values after this batch: ${r.map((e,t)=>`L${t+1}:${e}`).join(", ")}.`,laneVDisplay:[...t],laneCDisplay:[...r],laneBitCheckDisplay:a.map(e=>e?"-":"-"),laneBitOnDisplay:a.map(e=>e?"-":"-"),laneMaskDisplay:a.map(e=>e?"true":"false"),finalResult:"N/A",uniformIt:"-",uniformOffset:"-"}),{steps:c,finalCValuesForBatch:r}}let t=[0,0,0,0];const e=[];e.push({line:null,description:`Calling <span class="spmd-inline-code"><span class="gofn">countBits</span><span class="gopunct">(</span><span class="goty">[]byte</span><span class="gopunct">{</span>${y}<span class="gopunct">}</span><span class="gopunct">)</span></span>. Input <span class="spmd-inline-code"><span class="govar">a</span></span> is initialized. Four execution lanes available.`,laneVDisplay:["-","-","-","-"],laneCDisplay:[...t],laneBitCheckDisplay:["-","-","-","-"],laneBitOnDisplay:["-","-","-","-"],laneMaskDisplay:["true","true","true","true"],finalResult:"N/A",uniformIt:"-",uniformOffset:"-"}),e.push({line:s.varC,description:`<span class="spmd-inline-code"><span class="gokw">var</span> <span class="govar">c</span> <span class="gohypo">varying</span> <span class="goty">uint8</span></span>: Each lane gets its own <span class="spmd-inline-code"><span class="govar">c</span></span> (bit counter), initialized to 0.`,laneVDisplay:["-","-","-","-"],laneCDisplay:[...t],laneBitCheckDisplay:["-","-","-","-"],laneBitOnDisplay:["-","-","-","-"],laneMaskDisplay:["true","true","true","true"],finalResult:"N/A",uniformIt:"-",uniformOffset:"-"});const C=Math.ceil(a.length/i);for(let n=0;n<C;n++){const o=[];let c=!1;for(let e=0;e<i;e++){const t=n*i+e;t<a.length?(o.push(a[t]),c=!0):o.push("-")}if(!c&&n>0)continue;let r;n===0?r="first":n===1?r="second":n===2?r="third":r=`batch ${n+1}`;const d=o.map((e,t)=>e!=="-"?`<span class="spmd-inline-code"><span class="govar">v</span></span>=${e} (L${t+1})`:null).filter(Boolean).join(", "),u=`<span class="spmd-inline-code"><span class="gokw">go</span> <span class="gokw">for</span> <span class="govar">_</span><span class="gopunct">,</span> <span class="govar">v</span> <span class="goop">:=</span> <span class="gokw">range</span> <span class="govar">a</span></span>: Distributing ${r} batch. ${d}.`;e.push({line:s.goFor,description:u,laneVDisplay:o.map(e=>e!=="-"?e:"-"),laneCDisplay:[...t],laneBitCheckDisplay:o.map(()=>"-"),laneBitOnDisplay:o.map(()=>"-"),laneMaskDisplay:o.map(e=>e!=="-"?"true":"false"),finalResult:"N/A",uniformIt:"-",uniformOffset:"-"});const l=w(n+1,o,t,s);e.push(...l.steps),t=[...l.finalCValuesForBatch]}e.push({line:s.endGoFor,description:`The <span class="spmd-inline-code"><span class="gokw">go</span> <span class="gokw">for</span></span> loop (lines ${s.goFor}-${s.endGoFor}) finishes. All elements from <span class="spmd-inline-code"><span class="govar">a</span></span> processed. Final <span class="spmd-inline-code"><span class="govar">c</span></span> values per lane: ${t.join(", ")}.`,laneVDisplay:["-","-","-","-"],laneCDisplay:[...t],laneBitCheckDisplay:["-","-","-","-"],laneBitOnDisplay:["-","-","-","-"],laneMaskDisplay:["true","true","true","true"],finalResult:"N/A",uniformIt:"-",uniformOffset:"-"}),e.push({line:s.reduceAdd,description:`Aggregating <span class="spmd-inline-code"><span class="govar">c</span></span> values from all lanes using <span class="spmd-inline-code"><span class="gokw">return</span> <span class="gofn">reduce.Add</span><span class="gopunct">(</span><span class="govar">c</span><span class="gopunct">)</span></span>. Summing: ${t.join(" + ")}.`,laneVDisplay:["-","-","-","-"],laneCDisplay:[...t],laneBitCheckDisplay:["-","-","-","-"],laneBitOnDisplay:["-","-","-","-"],laneMaskDisplay:["true","true","true","true"],finalResult:r,uniformIt:"-",uniformOffset:"-"}),e.push({line:s.funcEnd,description:`Function returns the total bit count: <span class="spmd-inline-code">${r}</span>.`,laneVDisplay:["-","-","-","-"],laneCDisplay:[...t],laneBitCheckDisplay:["-","-","-","-"],laneBitOnDisplay:["-","-","-","-"],laneMaskDisplay:["true","true","true","true"],finalResult:r,uniformIt:"-",uniformOffset:"-"});let o=0;function c(t){const s=e[t];if(x.forEach(e=>e.classList.remove("highlight")),s.line!==null){const e=document.querySelector(`#spmd-go-code_countbits .code-line[data-line="${s.line}"]`);e&&e.classList.add("highlight")}E.innerHTML=s.description;const o=typeof s.itVal=="number"?s.itVal:null;for(let e=0;e<i;e++){const t=s.laneMaskDisplay[e]==="true";[f[e],g[e],v[e],b[e]].forEach(e=>{t?e.classList.remove("inactive-lane"):e.classList.add("inactive-lane")}),u[e].classList.remove("inactive-lane");const a=typeof s.laneVDisplay[e]=="number"?`<span class="spmd-binary-value">${n(s.laneVDisplay[e],o)}</span>`:s.laneVDisplay[e];f[e].innerHTML=a,g[e].textContent=s.laneCDisplay[e];const r=typeof s.laneBitCheckDisplay[e]=="number"?`<span class="spmd-binary-value">${n(s.laneBitCheckDisplay[e],o)}</span>`:s.laneBitCheckDisplay[e];v[e].innerHTML=r,b[e].textContent=typeof s.laneBitOnDisplay[e]=="boolean"?s.laneBitOnDisplay[e].toString():s.laneBitOnDisplay[e],u[e].textContent=s.laneMaskDisplay[e]}if(s.uniformIt!==void 0&&(k.textContent=s.uniformIt),s.uniformOffset!==void 0&&(j.innerHTML=typeof s.uniformOffset=="string"&&s.uniformOffset.includes("<span")?s.uniformOffset:s.uniformOffset),s.finalResult!=="N/A"){const e=s.laneCDisplay.filter(e=>typeof e=="number");d.textContent=e.join(" + "),l.style.display="inline",p.textContent=s.finalResult}else d.textContent="",l.style.display="none",p.textContent="N/A";h.disabled=t===0,m.disabled=t===e.length-1}h.addEventListener("click",()=>{o>0&&(o--,c(o))}),m.addEventListener("click",()=>{o<e.length-1&&(o++,c(o))}),c(o)})</script><blockquote><p>NOTE: For simplicity of the example and because I do not want everyone to have to click 32 times in the inner loop, I went with byte and uint8 type here. In a more practical implementation of this function, I should be manipulating int32 directly and write the inner loop test just inside the if like so <strong><code>if v & (1 &lt;&lt; it) != 0 {</code></strong>. The compiler should be able to match this loop with a popcount instruction if the hardware support it. Basically there is no reason that this would be any slower than a more direct to assembly approach, but it keep its readability in my opinion.</p></blockquote><p>This was a fairly simple <strong><code>for</code></strong> loop that operate on uniform with the same value for all lanes, but it shows how manipulating the mask enable all the complexity in behavior we could want. We can nest loop, if. We can also implement <strong><code>break</code></strong> and <strong><code>continue</code></strong> using just mask.</p><h2 id=divergent-control-flow>Divergent Control Flow</h2><p>The previous example showed lanes executing the same loop with uniform iteration counts. But what happens when different lanes need to execute loops of different lengths? This is where SPMD really shines - it can handle <strong>divergent control flow</strong> where each lane follows a different execution path.</p><p>Consider this example where we sum arrays of different lengths:</p><style>#spmd-lane-data-grid_countarray .spmd-grid-cell:not(.inactive-lane){color:#000!important}#spmd-lane-data-grid_countarray .spmd-grid-cell[id*=-secondLevel]:not(.inactive-lane){font-weight:700;font-size:.8em}#spmd-lane-data-grid_countarray .spmd-grid-cell[id*=-t]:not(.inactive-lane){font-weight:700}#spmd-lane-data-grid_countarray .spmd-grid-cell[id*=-v]:not(.inactive-lane){font-weight:700}</style><div class=spmd-container><div id=spmd-demo_countarray class=spmd-demo><div class=spmd-code-pane><pre><code id=spmd-go-code_countarray class=language-go>
<span class=code-line data-line=1><span class=gokw>func</span> <span class=gofn>CountArray</span><span class=gopunct>(</span><span class=govar>a</span> <span class=goty>[][]int</span><span class=gopunct>)</span> <span class=goty>[]int</span> <span class=gopunct>{</span></span>
<span class=code-line data-line=2>    <span class=govar>r</span> <span class=goop>:=</span> <span class=gofn>make</span><span class=gopunct>(</span><span class=goty>[]int</span><span class=gopunct>,</span> <span class=gofn>len</span><span class=gopunct>(</span><span class=govar>a</span><span class=gopunct>))</span></span>
<span class=code-line data-line=3>    <span class=gokw>go</span> <span class=gokw>for</span> <span class=govar>i</span><span class=gopunct>,</span> <span class=govar>secondLevel</span> <span class=goop>:=</span> <span class=gokw>range</span> <span class=govar>a</span> <span class=gopunct>{</span></span>
<span class=code-line data-line=4>        <span class=govar>t</span> <span class=goop>:=</span> <span class=gonum>0</span></span>
<span class=code-line data-line=5>        <span class=gokw>for</span> <span class=govar>_</span><span class=gopunct>,</span> <span class=govar>v</span> <span class=goop>:=</span> <span class=gokw>range</span> <span class=govar>secondLevel</span> <span class=gopunct>{</span></span>
<span class=code-line data-line=6>            <span class=govar>t</span> <span class=goop>+=</span> <span class=govar>v</span></span>
<span class=code-line data-line=7>        <span class=gopunct>}</span></span>
<span class=code-line data-line=8>        <span class=govar>r</span><span class=gopunct>[</span><span class=govar>i</span><span class=gopunct>]</span> <span class=goop>=</span> <span class=govar>t</span></span>
<span class=code-line data-line=9>    <span class=gopunct>}</span></span>
<span class=code-line data-line=10>    <span class=gokw>return</span> <span class=govar>r</span></span>
<span class=code-line data-line=11><span class=gopunct>}</span></span>
            </code></pre></div><div class=spmd-viz-pane><div id=spmd-lane-data-grid_countarray class=spmd-lane-data-grid><div class=spmd-grid-label></div><div class=spmd-grid-header>Lane 1</div><div class=spmd-grid-header>Lane 2</div><div class=spmd-grid-header>Lane 3</div><div class=spmd-grid-header>Lane 4</div><div class=spmd-grid-label>mask:</div><div class=spmd-grid-cell id=spmd-lane-0-mask_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-1-mask_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-2-mask_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-3-mask_countarray>-</div><div class=spmd-grid-label>i:</div><div class=spmd-grid-cell id=spmd-lane-0-i_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-1-i_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-2-i_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-3-i_countarray>-</div><div class=spmd-grid-label>secondLevel:</div><div class=spmd-grid-cell id=spmd-lane-0-secondLevel_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-1-secondLevel_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-2-secondLevel_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-3-secondLevel_countarray>-</div><div class=spmd-grid-label>t:</div><div class=spmd-grid-cell id=spmd-lane-0-t_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-1-t_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-2-t_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-3-t_countarray>-</div><div class=spmd-grid-label>v:</div><div class=spmd-grid-cell id=spmd-lane-0-v_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-1-v_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-2-v_countarray>-</div><div class=spmd-grid-cell id=spmd-lane-3-v_countarray>-</div></div><div class=spmd-final-result><h4>Final Result</h4><div class=result-lines-container><div class=result-line><span class=spmd-result-label>r:</span>
<span class=spmd-result-value-group><span id=spmd-final-result-value_countarray class=spmd-final-value-text>N/A</span></span></div></div></div><div class=spmd-controls><button id=spmd-prev-step_countarray>Previous</button>
<button id=spmd-next-step_countarray>Next</button></div></div></div><div class=spmd-info-pane><h4>Execution Step:</h4><p id=spmd-step-description_countarray>Initializing visualization...</p></div></div><script>document.addEventListener("DOMContentLoaded",()=>{const y=document.querySelectorAll("#spmd-go-code_countarray .code-line"),j=document.getElementById("spmd-step-description_countarray"),r=[document.getElementById("spmd-lane-0-i_countarray"),document.getElementById("spmd-lane-1-i_countarray"),document.getElementById("spmd-lane-2-i_countarray"),document.getElementById("spmd-lane-3-i_countarray")],c=[document.getElementById("spmd-lane-0-secondLevel_countarray"),document.getElementById("spmd-lane-1-secondLevel_countarray"),document.getElementById("spmd-lane-2-secondLevel_countarray"),document.getElementById("spmd-lane-3-secondLevel_countarray")],a=[document.getElementById("spmd-lane-0-t_countarray"),document.getElementById("spmd-lane-1-t_countarray"),document.getElementById("spmd-lane-2-t_countarray"),document.getElementById("spmd-lane-3-t_countarray")],i=[document.getElementById("spmd-lane-0-v_countarray"),document.getElementById("spmd-lane-1-v_countarray"),document.getElementById("spmd-lane-2-v_countarray"),document.getElementById("spmd-lane-3-v_countarray")],d=[document.getElementById("spmd-lane-0-mask_countarray"),document.getElementById("spmd-lane-1-mask_countarray"),document.getElementById("spmd-lane-2-mask_countarray"),document.getElementById("spmd-lane-3-mask_countarray")],u=document.getElementById("spmd-final-result-value_countarray"),h=document.getElementById("spmd-prev-step_countarray"),m=document.getElementById("spmd-next-step_countarray"),o=4,v=[[1,2,3],[4],[5,6,7],[8,9]],f=[6,4,18,17];function g(e){return Array.isArray(e)?"["+e.join(",")+"]":e}const n={func:1,makeR:2,goFor:3,tInit:4,forV:5,tIncrement:6,endInnerLoop:7,rAssignment:8,endGoFor:9,returnR:10,funcEnd:11};function p(e){let t=[],s=Math.max(...e.map(e=>e.array.length));for(let i=0;i<s;i++){let a=e.map((e)=>i<e.array.length);if(!a.some(e=>e))break;t.push({line:n.forV,description:`Inner loop iteration ${i+1}: <span class="spmd-inline-code"><span class="gokw">for</span> <span class="govar">_</span><span class="gopunct">,</span> <span class="govar">v</span> <span class="goop">:=</span> <span class="gokw">range</span> <span class="govar">secondLevel</span></span>. Active lanes get their next values.`,laneStates:e.map((e,t)=>({...e,currentV:a[t]?e.array[i]:void 0,currentIndex:i,finished:!a[t]}))});for(let t=0;t<o;t++)a[t]?(e[t].t+=e[t].array[i],e[t].currentV=e[t].array[i],e[t].currentIndex=i):(e[t].currentV=void 0,e[t].finished=!0);t.push({line:n.tIncrement,description:`<span class="spmd-inline-code"><span class="govar">t</span> <span class="goop">+=</span> <span class="govar">v</span></span>: Adding current <span class="spmd-inline-code"><span class="govar">v</span></span> to running total <span class="spmd-inline-code"><span class="govar">t</span></span> in active lanes. ${a.map((t,n)=>t?`Lane ${n+1}: t=${e[n].t}`:`Lane ${n+1}: finished`).join(", ")}.`,laneStates:JSON.parse(JSON.stringify(e))})}return t.push({line:n.endInnerLoop,description:`Inner loop completes. All lanes have finished processing their respective <span class="spmd-inline-code"><span class="govar">secondLevel</span></span> arrays. Final totals: ${e.map((e,t)=>`Lane ${t+1}: ${e.t}`).join(", ")}.`,laneStates:JSON.parse(JSON.stringify(e))}),t}const e=[];e.push({line:null,description:`Calling <span class="spmd-inline-code"><span class="gofn">CountArray</span><span class="gopunct">(</span><span class="goty">[][]int</span><span class="gopunct">{</span>{1,2,3},{4},{5,6,7},{8,9}<span class="gopunct">}</span><span class="gopunct">)</span></span>. Input <span class="spmd-inline-code"><span class="govar">a</span></span> contains 4 sub-arrays of different lengths.`,laneStates:null}),e.push({line:n.makeR,description:`<span class="spmd-inline-code"><span class="govar">r</span> <span class="goop">:=</span> <span class="gofn">make</span><span class="gopunct">(</span><span class="goty">[]int</span><span class="gopunct">,</span> <span class="gofn">len</span><span class="gopunct">(</span><span class="govar">a</span><span class="gopunct">))</span></span>: Creating result slice with length 4 to store the sums.`,laneStates:null});let t=[];for(let e=0;e<o;e++)t.push({i:e,array:v[e],t:0,currentIndex:0,currentV:void 0,finished:!1});e.push({line:n.goFor,description:`<span class="spmd-inline-code"><span class="gokw">go</span> <span class="gokw">for</span> <span class="govar">i</span><span class="gopunct">,</span> <span class="govar">secondLevel</span> <span class="goop">:=</span> <span class="gokw">range</span> <span class="govar">a</span></span>: Distributing 4 sub-arrays across 4 lanes. Lane 1 gets [1,2,3], Lane 2 gets [4], Lane 3 gets [5,6,7], Lane 4 gets [8,9].`,laneStates:JSON.parse(JSON.stringify(t))}),e.push({line:n.tInit,description:`<span class="spmd-inline-code"><span class="govar">t</span> <span class="goop">:=</span> <span class="gonum">0</span></span>: Initializing accumulator <span class="spmd-inline-code"><span class="govar">t</span></span> to 0 in each lane.`,laneStates:JSON.parse(JSON.stringify(t))});const b=p(JSON.parse(JSON.stringify(t)));e.push(...b);for(let e=0;e<o;e++)t[e].t=f[e],t[e].currentV=void 0,t[e].finished=!1;e.push({line:n.rAssignment,description:`<span class="spmd-inline-code"><span class="govar">r</span><span class="gopunct">[</span><span class="govar">i</span><span class="gopunct">]</span> <span class="goop">=</span> <span class="govar">t</span></span>: Storing final sums in result array. This is a <strong>scatter operation</strong> - uniform pointer <span class="spmd-inline-code"><span class="govar">r</span></span> with varying offsets <span class="spmd-inline-code"><span class="govar">i</span></span> (0,1,2,3). All lanes active: r[0]=6, r[1]=4, r[2]=18, r[3]=17.`,laneStates:JSON.parse(JSON.stringify(t))}),e.push({line:n.endGoFor,description:`The <span class="spmd-inline-code"><span class="gokw">go</span> <span class="gokw">for</span></span> loop completes. All lanes have finished processing their respective sub-arrays.`,laneStates:JSON.parse(JSON.stringify(t)),finalResult:"[6, 4, 18, 17]"}),e.push({line:n.returnR,description:`<span class="spmd-inline-code"><span class="gokw">return</span> <span class="govar">r</span></span>: Function returns the result array [6, 4, 18, 17].`,laneStates:JSON.parse(JSON.stringify(t)),finalResult:"[6, 4, 18, 17]"});let s=0;function l(t){const n=e[t];if(y.forEach(e=>e.classList.remove("highlight")),n.line!==null){const e=document.querySelector(`#spmd-go-code_countarray .code-line[data-line="${n.line}"]`);e&&e.classList.add("highlight")}if(j.innerHTML=n.description,n.laneStates)for(let e=0;e<o;e++){const t=n.laneStates[e],s=!t.finished&&(t.currentIndex===void 0||t.currentIndex<t.array.length),u=t.finished;d[e].textContent=s?"true":"false",r[e].textContent=t.i,c[e].textContent=g(t.array),a[e].textContent=t.t,i[e].textContent=t.currentV!==void 0?t.currentV:"-";const l=[r[e],c[e],a[e],i[e]];l.forEach(e=>{e.classList.remove("inactive-lane"),s||e.classList.add("inactive-lane")}),d[e].classList.remove("inactive-lane")}else for(let e=0;e<o;e++){d[e].textContent="-",r[e].textContent="-",c[e].textContent="-",a[e].textContent="-",i[e].textContent="-";const t=[r[e],c[e],a[e],i[e]];t.forEach(e=>{e.classList.remove("inactive-lane")})}n.finalResult?u.textContent=n.finalResult:u.textContent="N/A",h.disabled=t===0,m.disabled=t===e.length-1}h.addEventListener("click",()=>{s>0&&(s--,l(s))}),m.addEventListener("click",()=>{s<e.length-1&&(s++,l(s))}),l(s)})</script><p>This example demonstrates a key SPMD concept: <strong>lanes can finish their work at different times</strong>. Lane 2 finishes after processing just one element <code>[4]</code>, while Lane 3 continues processing three elements <code>[5,6,7]</code>. The SPMD execution model handles this gracefully by using masks - when a lane finishes its inner loop, it becomes inactive (masked out) while other lanes continue executing.</p><p>This is fundamentally different from traditional SIMD where all lanes must execute the same instruction. In our SPMD model, the compiler can generate efficient code that handles divergent control flow, making it practical for real-world algorithms where data doesn&rsquo;t always fit neat, uniform patterns.</p><h2 id=summary>Summary</h2><p>And we have shown that it is possible to extend Go with just a few keyword and make writing data parallel algorithm approachable, more readable and maintainable in my opinion. Let me know if there is anything that need clarification.</p><p>Adding data parallelism as a first-class feature in Go could make high-performance computing more accessible and portable. By learning from languages like ISPC and Mojo, we can imagine a future where Go code is simple, fast and leverage the full power of modern hardware. Even if Go never adopts these features, understanding them can help you write shader, compute kernel and code for Mojo or ISPC.</p><ul class=pa0></ul><div class="mt6 instapaper_ignoref"><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//bluebugs.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><div id=commento></div><script defer src=https://cdn.commento.io/js/commento.js></script></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=http://bluebugs.github.io/>&copy; Cedric Bail 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>