<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Cross-Lane Communication: When Lanes Need to Talk | Cedric Bail</title>
<meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Understanding why and how SPMD programs coordinate data between execution lanes through base64 decoding"><meta name=generator content="Hugo 0.136.0"><meta name=robots content="index, follow"><meta name=author content="Cedric Bail"><link rel=stylesheet href=/ananke/css/main.min.b27b18f294c9951b5b631d08d9733f0d7794f951b8e49cdde160a91f5a65f320.css><link rel=canonical href=http://bluebugs.github.io/blogs/cross-lane-communication/><meta property="og:url" content="http://bluebugs.github.io/blogs/cross-lane-communication/"><meta property="og:site_name" content="Cedric Bail"><meta property="og:title" content="Cross-Lane Communication: When Lanes Need to Talk"><meta property="og:description" content="Understanding why and how SPMD programs coordinate data between execution lanes through base64 decoding"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="blogs"><meta property="article:published_time" content="2025-07-12T14:30:00-07:00"><meta property="article:modified_time" content="2025-07-12T14:30:00-07:00"><meta itemprop=name content="Cross-Lane Communication: When Lanes Need to Talk"><meta itemprop=description content="Understanding why and how SPMD programs coordinate data between execution lanes through base64 decoding"><meta itemprop=datePublished content="2025-07-12T14:30:00-07:00"><meta itemprop=dateModified content="2025-07-12T14:30:00-07:00"><meta itemprop=wordCount content="1336"><meta name=twitter:card content="summary"><meta name=twitter:title content="Cross-Lane Communication: When Lanes Need to Talk"><meta name=twitter:description content="Understanding why and how SPMD programs coordinate data between execution lanes through base64 decoding"></head><body class="ma0 avenir bg-near-white production"><header class="cover bg-center" style=background-image:url(http://bluebugs.github.io/images/lakelouise.jpg)><div class=bg-black-60><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/ class="f3 fw2 hover-white no-underline white-90 dib">Cedric Bail</a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=/blogs/ title="Blog page">Blog</a></li></ul><div class=ananke-socials></div></div></div></nav><div class="tc-l pv6 ph3 ph4-ns"><div class="f2 f1-l fw2 white-90 mb0 lh-title">Cross-Lane Communication: When Lanes Need to Talk</div><div class="fw1 f5 f3-l white-80 measure-wide-l center lh-copy mt3 mb4">Understanding why and how SPMD programs coordinate data between execution lanes through base64 decoding</div></div></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked ttu">Blog</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">Cross-Lane Communication: When Lanes Need to Talk</h1><p class=tracked>By <strong>Cedric Bail</strong></p><time class="f6 mv4 dib tracked" datetime=2025-07-12T14:30:00-07:00>July 12, 2025</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links black pr4-l w-two-thirds-l"><h2 id=when-independent-lanes-arent-enough>When Independent Lanes Aren&rsquo;t Enough</h2><p>Most SPMD examples show lanes working independently—each processing its own data without communicating with neighbors. But real-world algorithms often require <strong>cross-lane communication</strong>: lanes must exchange data to solve the problem correctly. Base64 decoding demonstrates this problem, transforming groups of 4 ASCII characters into groups of 3 bytes through coordinated lane operations.</p><p>This implementation draws inspiration from Miguel Young de la Sota&rsquo;s <a href=https://mcyoung.xyz/2023/11/27/simd-base64/>&ldquo;Designing a SIMD Algorithm from Scratch&rdquo;</a>, which explores the intricate challenges of building high-performance base64 decoders. Please go read his article if you want to really understand how and why this code work. I am just going to try in this article to show how it could be possible to do that in Go if we had a SPMD extension.</p><h2 id=the-problem-4-to-3-data-transformation>The Problem: 4-to-3 Data Transformation</h2><p>Base64 encoding converts every 3 bytes into 4 ASCII characters. Decoding reverses this: 4 ASCII characters become 3 bytes. This mismatch creates the core challenge—we can&rsquo;t simply process each character independently because the output structure differs from the input structure.</p><p>Let&rsquo;s look first at how we would iterate over all the data.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Package main demonstrates cross-lane communication in SPMD Go
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Based on: https://github.com/mcy/vb64/blob/main/src/simd.rs#L16-L144
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;lanes&#34;</span>
</span></span><span style=display:flex><span> <span style=color:#e6db74>&#34;reduce&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Decode</span>(<span style=color:#a6e22e>ascii</span> []<span style=color:#66d9ef>byte</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>ascii</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> len(<span style=color:#a6e22e>ascii</span>)<span style=color:#f92672>%</span><span style=color:#ae81ff>4</span> <span style=color:#f92672>!=</span> <span style=color:#ae81ff>0</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>false</span> <span style=color:#75715e>// Base64 requires input length multiple of 4
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#a6e22e>decoded</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>0</span>, len(<span style=color:#a6e22e>ascii</span>)<span style=color:#f92672>*</span><span style=color:#ae81ff>3</span><span style=color:#f92672>/</span><span style=color:#ae81ff>4</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>pattern</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>outputPattern</span>()
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>_</span>, <span style=color:#a6e22e>v</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span>[<span style=color:#ae81ff>4</span>] <span style=color:#a6e22e>ascii</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>decodedChunk</span>, <span style=color:#a6e22e>valid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>decodeChunk</span>(<span style=color:#a6e22e>v</span>, <span style=color:#a6e22e>pattern</span>)
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> !<span style=color:#a6e22e>valid</span> {
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>nil</span>, <span style=color:#66d9ef>false</span>
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>decoded</span> = append(<span style=color:#a6e22e>decoded</span>, <span style=color:#a6e22e>decodedChunk</span><span style=color:#f92672>...</span>)
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>decoded</span>, <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The <code>range[4] ascii</code> syntax indicates we&rsquo;re processing 4 bytes at a time in groups. This explicit sizing is crucial—the algorithm&rsquo;s cross-lane operations depend on having lane counts that are multiples of 4 to maintain the correct 4-to-3 byte transformation pattern.</p><h2 id=the-three-core-cross-lane-operations>The Three Core Cross-Lane Operations</h2><p>Base64 decoding requires three fundamental cross-lane communication patterns. Let&rsquo;s understand each before seeing how they work together:</p><h3 id=1-swizzle-parallel-table-lookups>1. Swizzle: Parallel Table Lookups</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Each lane indexes into a shared lookup table
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>offsetTable</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>byte</span>{<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>19</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>191</span>, <span style=color:#ae81ff>191</span>, <span style=color:#ae81ff>185</span>, <span style=color:#ae81ff>185</span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>offsets</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>Swizzle</span>(<span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>From</span>(<span style=color:#a6e22e>offsetTable</span>), <span style=color:#a6e22e>hashes</span>)
</span></span></code></pre></div><p><strong>What it does</strong>: <code>lanes.Swizzle</code> allows each lane to access any position in a shared array based on its computed index. Lane 0 might read position 3, lane 1 might read position 6, etc.</p><p><strong>Why it&rsquo;s powerful</strong>: This enables parallel table lookups where each lane can access different data simultaneously—like multiple hands reaching into different positions of the same toolbox at once.</p><h3 id=2-rotation-neighboring-data-exchange>2. Rotation: Neighboring Data Exchange</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Lane N receives data from lane N-1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>decodedChunks</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>shiftedLo</span> | <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>Rotate</span>(<span style=color:#a6e22e>shiftedHi</span>, <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p><strong>What it does</strong>: <code>lanes.Rotate</code> shifts data between adjacent lanes. With a rotation of 1, lane 0 gets data from lane 3, lane 1 gets data from lane 0, and so on.</p><p><strong>Why it&rsquo;s essential</strong>: Base64&rsquo;s 6-to-8 bit conversion creates bit patterns that span lane boundaries. Each lane needs some bits from its neighbor to form complete bytes.</p><h3 id=3-output-pattern-selective-extraction>3. Output Pattern: Selective Extraction</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>outputPattern</span>() <span style=color:#a6e22e>varying</span>[<span style=color:#ae81ff>4</span>] <span style=color:#66d9ef>uint8</span> {
</span></span><span style=display:flex><span> <span style=color:#66d9ef>var</span> <span style=color:#a6e22e>r</span> <span style=color:#a6e22e>varying</span>[<span style=color:#ae81ff>4</span>] <span style=color:#66d9ef>uint8</span>
</span></span><span style=display:flex><span> <span style=color:#66d9ef>go</span> <span style=color:#66d9ef>for</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>range</span>[<span style=color:#ae81ff>4</span>] {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>r</span>[<span style=color:#a6e22e>i</span>] = uint8(<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>i</span><span style=color:#f92672>/</span><span style=color:#ae81ff>3</span>) <span style=color:#75715e>// Creates: [0,1,2,4]
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> }
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>r</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Use pattern to select final bytes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>output</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>Swizzle</span>(<span style=color:#a6e22e>decodedChunks</span>, <span style=color:#a6e22e>pattern</span>)
</span></span></code></pre></div><p><strong>What it does</strong>: The pattern <code>[0,1,2,4]</code> selects specific positions from the decoded data, skipping every fourth element. For larger lane counts, this extends to <code>[0,1,2,4,5,6,8,9,10,12,...]</code>.</p><p><strong>Why it&rsquo;s clever</strong>: This elegant pattern automatically handles &ldquo;contamination&rdquo; from rotation operations that cross group boundaries—contaminated data lands in positions that get discarded anyway.</p><h2 id=the-complete-algorithm>The Complete Algorithm</h2><p>Now let&rsquo;s see how these operations work together in the complete <code>decodeChunk</code> function:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>decodeChunk</span>(<span style=color:#a6e22e>ascii</span> <span style=color:#a6e22e>varying</span>[<span style=color:#ae81ff>4</span>] <span style=color:#66d9ef>byte</span>, <span style=color:#a6e22e>pattern</span> <span style=color:#a6e22e>varying</span>[<span style=color:#ae81ff>4</span>] <span style=color:#66d9ef>uint8</span>) ([]<span style=color:#66d9ef>byte</span>, <span style=color:#66d9ef>bool</span>) {
</span></span><span style=display:flex><span> <span style=color:#75715e>// Step 1: Perfect hash function for table indexing
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>hashes</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>ShiftRight</span>(<span style=color:#a6e22e>ascii</span>, <span style=color:#ae81ff>4</span>) 
</span></span><span style=display:flex><span> <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>ascii</span> <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;/&#39;</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>hashes</span> <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span> }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e>// Step 2: Convert ASCII to 6-bit values via table lookup (Swizzle)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>offsetTable</span> <span style=color:#f92672>:=</span> []<span style=color:#66d9ef>byte</span>{<span style=color:#ae81ff>255</span>, <span style=color:#ae81ff>16</span>, <span style=color:#ae81ff>19</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>191</span>, <span style=color:#ae81ff>191</span>, <span style=color:#ae81ff>185</span>, <span style=color:#ae81ff>185</span>}
</span></span><span style=display:flex><span> <span style=color:#a6e22e>offsets</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>Swizzle</span>(<span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>From</span>(<span style=color:#a6e22e>offsetTable</span>), <span style=color:#a6e22e>hashes</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>sextets</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>ascii</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>offsets</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e>// Step 3: Validate characters using parallel lookups (Swizzle + Reduction)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>loLUT</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>From</span>([]<span style=color:#66d9ef>byte</span>{
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0b10101</span>, <span style=color:#ae81ff>0b10001</span>, <span style=color:#ae81ff>0b10001</span>, <span style=color:#ae81ff>0b10001</span>, <span style=color:#ae81ff>0b10001</span>, <span style=color:#ae81ff>0b10001</span>, <span style=color:#ae81ff>0b10001</span>, <span style=color:#ae81ff>0b10001</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0b10001</span>, <span style=color:#ae81ff>0b10001</span>, <span style=color:#ae81ff>0b10011</span>, <span style=color:#ae81ff>0b11010</span>, <span style=color:#ae81ff>0b11011</span>, <span style=color:#ae81ff>0b11011</span>, <span style=color:#ae81ff>0b11011</span>, <span style=color:#ae81ff>0b11010</span>,
</span></span><span style=display:flex><span> })
</span></span><span style=display:flex><span> <span style=color:#a6e22e>hiLUT</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>From</span>([]<span style=color:#66d9ef>byte</span>{
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0b10000</span>, <span style=color:#ae81ff>0b10000</span>, <span style=color:#ae81ff>0b00001</span>, <span style=color:#ae81ff>0b00010</span>, <span style=color:#ae81ff>0b00100</span>, <span style=color:#ae81ff>0b01000</span>, <span style=color:#ae81ff>0b00100</span>, <span style=color:#ae81ff>0b01000</span>,
</span></span><span style=display:flex><span>  <span style=color:#ae81ff>0b10000</span>, <span style=color:#ae81ff>0b10000</span>, <span style=color:#ae81ff>0b10000</span>, <span style=color:#ae81ff>0b10000</span>, <span style=color:#ae81ff>0b10000</span>, <span style=color:#ae81ff>0b10000</span>, <span style=color:#ae81ff>0b10000</span>, <span style=color:#ae81ff>0b10000</span>,
</span></span><span style=display:flex><span> })
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> <span style=color:#a6e22e>lo</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>Swizzle</span>(<span style=color:#a6e22e>loLUT</span>, <span style=color:#a6e22e>ascii</span><span style=color:#f92672>&amp;</span><span style=color:#ae81ff>0x0f</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>hi</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>Swizzle</span>(<span style=color:#a6e22e>hiLUT</span>, <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>ShiftRight</span>(<span style=color:#a6e22e>ascii</span>, <span style=color:#ae81ff>4</span>))
</span></span><span style=display:flex><span> <span style=color:#a6e22e>valid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>Or</span>(<span style=color:#a6e22e>lo</span><span style=color:#f92672>&amp;</span><span style=color:#a6e22e>hi</span>) <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e>// Step 4: Pack 6-bit values into bytes with cross-lane coordination (Rotation)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>shiftPattern</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>From</span>([]<span style=color:#66d9ef>uint16</span>{<span style=color:#ae81ff>2</span>, <span style=color:#ae81ff>4</span>, <span style=color:#ae81ff>6</span>, <span style=color:#ae81ff>8</span>})
</span></span><span style=display:flex><span> <span style=color:#a6e22e>shifted</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>ShiftLeft</span>(<span style=color:#a6e22e>sextets</span>, <span style=color:#a6e22e>shiftPattern</span>)
</span></span><span style=display:flex><span> 
</span></span><span style=display:flex><span> <span style=color:#a6e22e>shiftedLo</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>varying</span>[<span style=color:#ae81ff>4</span>] byte(<span style=color:#a6e22e>shifted</span>)
</span></span><span style=display:flex><span> <span style=color:#a6e22e>shiftedHi</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>varying</span>[<span style=color:#ae81ff>4</span>] byte(<span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>ShiftRight</span>(<span style=color:#a6e22e>shifted</span>, <span style=color:#ae81ff>8</span>))
</span></span><span style=display:flex><span> <span style=color:#a6e22e>decodedChunks</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>shiftedLo</span> | <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>Rotate</span>(<span style=color:#a6e22e>shiftedHi</span>, <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span> <span style=color:#75715e>// Step 5: Extract final 3 bytes using output pattern (Swizzle)
</span></span></span><span style=display:flex><span><span style=color:#75715e></span> <span style=color:#a6e22e>output</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>lanes</span>.<span style=color:#a6e22e>Swizzle</span>(<span style=color:#a6e22e>decodedChunks</span>, <span style=color:#a6e22e>pattern</span>)
</span></span><span style=display:flex><span> <span style=color:#66d9ef>return</span> []byte(<span style=color:#a6e22e>output</span>), <span style=color:#a6e22e>valid</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=why-multiple-of-4-lane-counts-matter>Why Multiple-of-4 Lane Counts Matter</h2><p>Notice the explicit <code>varying[4]</code> types throughout the code. This isn&rsquo;t arbitrary—base64&rsquo;s 4-to-3 conversion requires lane counts that are multiples of 4. The cross-lane operations work correctly with any multiple of 4 because:</p><p>The <strong>Output patterns</strong> maintain the 4:3 ratio across lane groups, discarding the fourth byte that could be &ldquo;contaminated&rdquo; by rotation or shift operation. It is this pattern that make this algorithm work for any multiple of 4 lanes.</p><p>By specifying <code>varying[4]</code>, we tell the compiler: &ldquo;Process data in groups of 4. If the hardware has 8 lanes, run two groups in parallel. If it has 16 lanes, run four groups simultaneously. If it has fewer than 4 lanes, unroll the loop and interleave operations to ensure each step has the required 4 elements ready for processing.</p><p>This allow supporting all hardware with the same code. Relying on compiler to provide portability, but also readability and maintainability while not sacrificing performance.</p><h2 id=the-cost-of-communication>The Cost of Communication</h2><p>Cross-lane operations are expensive compared to independent lane operations:</p><ul><li><strong>Simple arithmetic</strong>: Each lane operates independently—very fast</li><li><strong>Shuffle/Swizzle</strong>: Lanes access arbitrary positions—moderately expensive when staying in register, get more expensive when accessing random memory</li><li><strong>Rotation/Shift</strong>: Each lane still operates independently as it is just directed to land in another lane-very fast</li><li><strong>Reduction</strong>: All-to-one communication—can be expensive depending on operation</li></ul><p>However, these costs enable algorithms impossible with purely independent processing. Base64 decoding with cross-lane communication can be significantly faster than scalar alternatives. The edge case of generating code for computer with no SIMD will be interesting to see if it impact the performance compared to current code.</p><h2 id=the-complexity-question>The Complexity Question</h2><p>Base64 decoding demonstrates how cross-lane operations can replace hand-written assembly with portable Go code. But this raises a fundamental question: <strong>Is the added complexity worth it?</strong></p><h3 id=what-we-gain>What We Gain</h3><ul><li><strong>Portability</strong>: Same algorithm works across different SIMD widths and architectures</li><li><strong>Performance</strong>: Potentially significant speedups for data transformation algorithms</li><li><strong>Maintainability</strong>: No platform-specific assembly to maintain</li></ul><h3 id=what-we-lose>What We Lose</h3><ul><li><strong>Simplicity</strong>: Code becomes inherently harder to review and understand</li><li><strong>Cognitive load</strong>: Developers must understand lane interactions, not just individual operations</li><li><strong>Debugging complexity</strong>: Cross-lane bugs are more subtle than simple arithmetic errors</li></ul><h3 id=the-minimal-alternative>The Minimal Alternative</h3><p>Perhaps the real question is whether we need the full suite of cross-lane operations, or if <strong>reduction alone</strong> would cover the majority of practical use cases:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#75715e>// Simple parallel processing with reduction
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sum</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>Add</span>(<span style=color:#a6e22e>data</span> <span style=color:#f92672>*</span> <span style=color:#a6e22e>coefficients</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>anyInvalid</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>Or</span>(<span style=color:#a6e22e>validation_results</span>)
</span></span><span style=display:flex><span><span style=color:#a6e22e>maximum</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>reduce</span>.<span style=color:#a6e22e>Max</span>(<span style=color:#a6e22e>lane_values</span>)
</span></span></code></pre></div><p>Reduction operations are:</p><ul><li><strong>Easier to understand</strong>: All-to-one communication is conceptually simpler</li><li><strong>Broadly applicable</strong>: Many algorithms only need to combine results, not exchange data</li><li><strong>Less error-prone</strong>: No risk of rotation contamination or swizzle index errors</li></ul><h3 id=the-design-decision>The Design Decision</h3><p>The base64 example shows what&rsquo;s possible with full cross-lane communication, but it also reveals the algorithmic complexity cost. For a Go SPMD extension, the choice might be:</p><ol><li><strong>Full suite</strong> (swizzle, rotation, reduction): Maximum capability, maximum complexity</li><li><strong>Reduction only</strong>: Simpler mental model, covers many common patterns</li><li><strong>Gradual introduction</strong>: Start with reduction, add others based on demonstrated need</li></ol><p>The question isn&rsquo;t just technical—it&rsquo;s about whether Go developers would adopt and correctly use these more complex operations, or if the cognitive overhead outweighs the performance benefits.</p><p><em>Implementation inspired by Miguel Young de la Sota&rsquo;s excellent analysis in <a href=https://mcyoung.xyz/2023/11/27/simd-base64/>&ldquo;Designing a SIMD Algorithm from Scratch&rdquo;</a>, adapted for hypothetical SPMD Go extension.</em></p><ul class=pa0></ul><div class="mt6 instapaper_ignoref"><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//bluebugs.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><div id=commento></div><script defer src=https://cdn.commento.io/js/commento.js></script></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=http://bluebugs.github.io/>&copy; Cedric Bail 2025</a><div><div class=ananke-socials></div></div></div></footer></body></html>