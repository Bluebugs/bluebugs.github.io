<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on Cedric Bail</title><link>http://bluebugs.github.io/blogs/</link><description>Recent content in Blog on Cedric Bail</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sun, 12 Jan 2025 14:38:38 -0700</lastBuildDate><atom:link href="http://bluebugs.github.io/blogs/index.xml" rel="self" type="application/rss+xml"/><item><title>What if? Readable, SIMD hex convertion</title><link>http://bluebugs.github.io/blogs/hex/</link><pubDate>Sun, 12 Jan 2025 14:38:38 -0700</pubDate><guid>http://bluebugs.github.io/blogs/hex/</guid><description>&lt;p>In my previous article, we looked at how we could introduce a more readable and maintainable way to express data parallelism in Go and used it for a quick &lt;code>Sum&lt;/code> example. In this article, I will look at implementing &lt;code>hex.Encode&lt;/code> and &lt;code>hex.Decode&lt;/code> with it to start a discussion based on some more practical example.&lt;/p>
&lt;h1 id="encode">Encode&lt;/h1>
&lt;p>Current implementation for hex.Encode looks like:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">Encode&lt;/span>(&lt;span style="color:#a6e22e">dst&lt;/span>, &lt;span style="color:#a6e22e">src&lt;/span> []&lt;span style="color:#66d9ef">byte&lt;/span>) &lt;span style="color:#66d9ef">int&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">for&lt;/span> &lt;span style="color:#a6e22e">_&lt;/span>, &lt;span style="color:#a6e22e">v&lt;/span> &lt;span style="color:#f92672">:=&lt;/span> &lt;span style="color:#66d9ef">range&lt;/span> &lt;span style="color:#a6e22e">src&lt;/span> {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">dst&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>] = &lt;span style="color:#a6e22e">hextable&lt;/span>[&lt;span style="color:#a6e22e">v&lt;/span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&lt;/span>&lt;span style="color:#ae81ff">4&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">dst&lt;/span>[&lt;span style="color:#a6e22e">j&lt;/span>&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>] = &lt;span style="color:#a6e22e">hextable&lt;/span>[&lt;span style="color:#a6e22e">v&lt;/span>&lt;span style="color:#f92672">&amp;amp;&lt;/span>&lt;span style="color:#ae81ff">0x0f&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>		&lt;span style="color:#a6e22e">j&lt;/span> &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	}
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>	&lt;span style="color:#66d9ef">return&lt;/span> len(&lt;span style="color:#a6e22e">src&lt;/span>) &lt;span style="color:#f92672">*&lt;/span> &lt;span style="color:#ae81ff">2&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>We will have to change a bit the algorithm and iterate on the &lt;code>EncodedLen&lt;/code> of &lt;code>src&lt;/code> to have a continuous iterator. With that in mind, let&amp;rsquo;s see how it would look like:&lt;/p></description></item><item><title>Parallel data manipulation to Go</title><link>http://bluebugs.github.io/blogs/govector/</link><pubDate>Sun, 12 Jan 2025 10:40:28 -0700</pubDate><guid>http://bluebugs.github.io/blogs/govector/</guid><description>&lt;p>In Go, we have the ability to execute multiple concurrent code path (concurrency) in parallel using goroutine. There has been consideration to add concurrency without parallelism with &lt;a href="https://research.swtch.com/coro">coroutine&lt;/a>, but we haven&amp;rsquo;t really explored the concept of getting parallelism without concurrency.&lt;/p>
&lt;h1 id="what-is-parallelism-without-concurrency">What is parallelism without concurrency?&lt;/h1>
&lt;p>The idea is that the same code is executed on an array of data in parallel. This is how language like Cuda, OpenCL or even shaders language work with GPU. For shaders, for example, you code the algorithm that is going to be applied to each pixels, for example, and it will execute that code on all the pixels in parallel. Same code, different data. No code concurrency, just data parallelism. And the code can adapt to the capacity of the hardware (number of unit doing computation in parallel) without change.&lt;/p></description></item><item><title>Layoffs in Tech: Impacts on Teams and Technical Debt</title><link>http://bluebugs.github.io/blogs/layoff-tech-debt/</link><pubDate>Wed, 13 Nov 2024 18:31:52 -0700</pubDate><guid>http://bluebugs.github.io/blogs/layoff-tech-debt/</guid><description>&lt;p>The tech sector, after a decade of remarkable growth, has faced significant layoffs. These events affect everyone-not just those directly impacted, but also the colleagues who remain. For those let go, the challenges of finding new opportunities in a tough market are profound. Meanwhile, those who stay often grapple with shaken trust in management, increased workloads, and heightened stress about their own job security.&lt;/p>
&lt;p>Much has been written about these emotional and logistical challenges. However, one crucial aspect remains underexplored: the impact of layoffs on technical debt and how it evolves in downsized teams.&lt;/p></description></item><item><title>Tests Debt</title><link>http://bluebugs.github.io/blogs/tests-debt/</link><pubDate>Sat, 09 Nov 2024 14:20:32 -0700</pubDate><guid>http://bluebugs.github.io/blogs/tests-debt/</guid><description>&lt;p>Tests should help you release code faster and with confidence. Yet, for many developers, testing has the opposite effect, creating delays and frustration. Here, I&amp;rsquo;ll explore common pitfalls in testing and suggest better practices to make tests truly beneficial.&lt;/p>
&lt;p>We have all heard that we need to have more tests and that we should have as close to 100% tests coverage as possible. Despite this effort, we still encounter bugs. We still do manual testing and overall a lot of developers do not trust their tests to actually catch anything useful. Why is that?&lt;/p></description></item><item><title>The SuperH family</title><link>http://bluebugs.github.io/blogs/first-post/</link><pubDate>Tue, 29 Oct 2024 20:49:45 -0600</pubDate><guid>http://bluebugs.github.io/blogs/first-post/</guid><description>&lt;p>In this post, Iâ€™ll explore the SuperH instruction set and its relevance today, along with a tool I created to navigate it.&lt;/p>
&lt;p>A few years ago, I met some of the members of the team behind the development of the &lt;em>J-Core&lt;/em>, a &lt;em>SuperH&lt;/em> clone, and had some really interesting discussions with them. Using this &lt;a href="http://www.shared-ptr.com/sh_insns.html">resource&lt;/a>, I created, for my own understanding, a &lt;a href="https://bluebugs.github.io/json/insns.json">JSON file&lt;/a> and the dynamic table below to help me navigate and understand the &lt;em>SuperH&lt;/em> instruction set. I also added J2-related instructions that were not present in the initial material. As I turn off my &lt;em>AWS&lt;/em> account, I realized I could just share it via a &lt;em>GitHub&lt;/em> page. Here is a bit more context about &lt;em>SuperH&lt;/em>.&lt;/p></description></item></channel></rss>