<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cedric Bail</title><link>http://bluebugs.github.io/</link><description>Recent content on Cedric Bail</description><generator>Hugo</generator><language>en-us</language><lastBuildDate>Sat, 21 Jun 2025 14:38:38 -0700</lastBuildDate><atom:link href="http://bluebugs.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>What if? Practical parallel data.</title><link>http://bluebugs.github.io/blogs/practical-vector/</link><pubDate>Sat, 21 Jun 2025 14:38:38 -0700</pubDate><guid>http://bluebugs.github.io/blogs/practical-vector/</guid><description>&lt;h2 id="printf-helper">Printf helper&lt;/h2>
&lt;p>One of the first and most repetitive tasks for &lt;a href="https://github.com/golang/go/blob/master/src/fmt/print.go#L1028">doPrintf&lt;/a> is to find &lt;code>%&lt;/code> in a string. Right now, this is just iterating one character after another. This is very simple to parallelize using data parallelism and would look like the code below.&lt;/p></description></item><item><title>Data Parallelism: simpler solution for Golang?</title><link>http://bluebugs.github.io/blogs/go-data-parallelism/</link><pubDate>Thu, 19 Jun 2025 18:48:59 -0700</pubDate><guid>http://bluebugs.github.io/blogs/go-data-parallelism/</guid><description>&lt;h2 id="why-data-parallelism-matters-in-go">Why Data Parallelism Matters in Go&lt;/h2>
&lt;p>Go is a fast language, but it lacks easy ways to express data parallelism and does not provide direct access to low-level &lt;strong>SIMD&lt;/strong> (Single Instruction Multiple Data) instructions. As a result, standard libraries like &lt;a href="https://github.com/golang/go/issues/19636">base64&lt;/a>, &lt;a href="https://github.com/golang/go/issues/68188">hex&lt;/a>, &lt;a href="https://github.com/golang/go/issues/63347">utf8&lt;/a>, &lt;a href="https://github.com/golang/go/issues/53178">json&lt;/a>, &lt;a href="https://github.com/golang/go/issues/24499">jpeg&lt;/a>, and &lt;a href="https://github.com/golang/go/issues/71255">map&lt;/a> are slower than expected. Other ecosystems are more likely to adopt specialized, high-performance libraries, which is why, in some cases, for example, Node.js can outperform Go.&lt;/p>
&lt;p>The solution to this bottleneck is for the Go compiler to generate SIMD instructions. There are three main approaches to enabling SIMD in programming languages:&lt;/p></description></item><item><title>Layoffs in Tech: Impacts on Teams and Technical Debt</title><link>http://bluebugs.github.io/blogs/layoff-tech-debt/</link><pubDate>Wed, 13 Nov 2024 18:31:52 -0700</pubDate><guid>http://bluebugs.github.io/blogs/layoff-tech-debt/</guid><description>&lt;p>The tech sector, after a decade of remarkable growth, has faced significant layoffs. These events affect everyone-not just those directly impacted, but also the colleagues who remain. For those let go, the challenges of finding new opportunities in a tough market are profound. Meanwhile, those who stay often grapple with shaken trust in management, increased workloads, and heightened stress about their own job security.&lt;/p>
&lt;p>Much has been written about these emotional and logistical challenges. However, one crucial aspect remains underexplored: the impact of layoffs on technical debt and how it evolves in downsized teams.&lt;/p></description></item><item><title>Tests Debt</title><link>http://bluebugs.github.io/blogs/tests-debt/</link><pubDate>Sat, 09 Nov 2024 14:20:32 -0700</pubDate><guid>http://bluebugs.github.io/blogs/tests-debt/</guid><description>&lt;p>Tests should help you release code faster and with confidence. Yet, for many developers, testing has the opposite effect, creating delays and frustration. Here, I&amp;rsquo;ll explore common pitfalls in testing and suggest better practices to make tests truly beneficial.&lt;/p>
&lt;p>We have all heard that we need to have more tests and that we should have as close to 100% tests coverage as possible. Despite this effort, we still encounter bugs. We still do manual testing and overall a lot of developers do not trust their tests to actually catch anything useful. Why is that?&lt;/p></description></item><item><title>The SuperH family</title><link>http://bluebugs.github.io/blogs/first-post/</link><pubDate>Tue, 29 Oct 2024 20:49:45 -0600</pubDate><guid>http://bluebugs.github.io/blogs/first-post/</guid><description>&lt;p>In this post, Iâ€™ll explore the SuperH instruction set and its relevance today, along with a tool I created to navigate it.&lt;/p>
&lt;p>A few years ago, I met some of the members of the team behind the development of the &lt;em>J-Core&lt;/em>, a &lt;em>SuperH&lt;/em> clone, and had some really interesting discussions with them. Using this &lt;a href="http://www.shared-ptr.com/sh_insns.html">resource&lt;/a>, I created, for my own understanding, a &lt;a href="https://bluebugs.github.io/json/insns.json">JSON file&lt;/a> and the dynamic table below to help me navigate and understand the &lt;em>SuperH&lt;/em> instruction set. I also added J2-related instructions that were not present in the initial material. As I turn off my &lt;em>AWS&lt;/em> account, I realized I could just share it via a &lt;em>GitHub&lt;/em> page. Here is a bit more context about &lt;em>SuperH&lt;/em>.&lt;/p></description></item></channel></rss>